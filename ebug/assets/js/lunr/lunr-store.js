var store = [{
        "title": "Calendar",
        "excerpt":"     App credit by Fabiau                              ","categories": [],
        "tags": [],
        "url": "/calendar/",
        "teaser": "/assets/images/apps/calendar_.png"
      },{
        "title": "Mac Os",
        "excerpt":"               App credit by Soroush Chehresa                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ","categories": [],
        "tags": [],
        "url": "/mac-os/",
        "teaser": "/assets/images/apps/macos_.png"
      },{
        "title": "Minesweeper",
        "excerpt":"App credit by Igor ","categories": [],
        "tags": [],
        "url": "/minesweeper/",
        "teaser": "/assets/images/apps/minesweeper_.png"
      },{
        "title": "Movies",
        "excerpt":"App credit by Huibo Ly","categories": [],
        "tags": [],
        "url": "/movies/",
        "teaser": "/assets/images/apps/movies_.png"
      },{
        "title": "React Js",
        "excerpt":"App credit by React.js","categories": [],
        "tags": [],
        "url": "/reactjs/",
        "teaser": "/assets/images/apps/reactjs_.png"
      },{
        "title": "World",
        "excerpt":" ","categories": [],
        "tags": [],
        "url": "/world/",
        "teaser": "/assets/images/apps/world_.png"
      },{
        "title": "블로그를 시작하며",
        "excerpt":" 개발 공간   여기는 특별한 공간이다. 아직 개발 되지 않은 타임머신이 존재하는 곳이기 때문이다. 물론 시간을 거슬러 되돌릴 수 없지만 미래로 향하여 빠르게 나아갈 수 있다.   특별한 공간에서 한잔의 아메리카노는 나에게 최상의 컨디션을 제공한다. 설마 카페인 중독일까..? 커피를 음미하다 보니 깊은 생각에 잠긴다.      ‘개발자로서 나는 어떤 사람인가?’   ‘지금 내 수준을 알고 있는가?’    나에 대한 질문에 쉽게 답을 못하는 나는 누구인가? 점차 나에 대한 정체성이 희미해져 간다. 나를 담는 공간이 필요하다.   또 다른 특별한 공간에 기록함으로 나에 대하여 명확히 알기를 원하며 블로그를 시작한다.    ","categories": [],
        "tags": ["Blog","Work Space","Americano"],
        "url": "/20210806/",
        "teaser": "/assets/images/20210806/0_.png"
      },{
        "title": "개인 블로그 생성하기",
        "excerpt":" 개인 블로그를 운영하기 위한 첫걸음으로 블로그의 종류에 대하여 알아보니 네이버 블로그, 티스토리, Velog 등 여러 플랫폼이 존재했다. 블로그에 대한 지식과 경험이 없는 상태에서 무엇을 선택할지 고민하다가 자연스럽게 개발자스러운(배움의 길이 무궁무진한) 플랫폼인 깃허브 페이지(GitHub Pages)를 선택했다.   GitHub Pages   GitHub Pages가 무엇인지 이해하기 앞서 GitHub란 무엇인지 궁금하여 검색을 통해 알아보았다. GitHub는 버전 관리와 협업을 위한 코드 호스팅 플랫폼이다. 버전 관리는 버전 관리 시스템(Version Control System:VCS)에서 파일에 변화를 시간에 따라 기록하고 특정 버전의 파일을 가져올 수 있는 기능이다. VCS로 관리되는 형상(소스 코드, 문서, 이미지 등)을 클라우드 저장소에 담고 있어 사용자간에 협업이 용이할 수 있게 제공된다.   GitHub Pages는 GitHub의 기능 중 하나로 클라우드 저장소에 내용을 웹호스팅 서비스로 제공된다. 즉 자신이 개발한 웹페이지를 복잡한 웹서버를 구축하지 않고 서비스 할 수 있도록 도와주는 도구이다.   GitHub Pages 시작하기   1. GitHub 계정 생성하기      GitHub Pages는 GitHub 계정당 하나의 사이트가 제공된다. 계정이 없는 경우 계정당 하나의 이메일 인증으로 계정을 생성할 수 있다. 비밀번호는 숫자와 소문자를 포함한 8 ~ 15자 이내로 만들어야 한다.   2. 저장소 만들기         로그인 후 메인화면 좌측 상단에 Create repository 또는 New 버튼을 클릭한다.   이미 원하는 Jekyll 테마의 URL 정보를 취득한 경우 Import repository 버튼을 클릭 하고 여기를 눌러 다음 단계를 건너띈다.      Owner와 Repository name을 입력하고 Create repository 버튼을 눌러 저장소를 생성 한다. Owner와 Repository name 값을 동일하게 입력할 때 위와 같이 시크릿 메시지가 출력 되며 README.md에 내용이 자동으로 GitHub 메인 사이트와 연동된다.   3. Jekyll Theme 활용하기   Jekyll은 GitHub Pages에 대한 지원이 내장된 정적 웹사이트 생성기이다. GitHub 저장소 내 Markdown, HTML 등 파일을 정해진 규약으로 가져와 선택한 레이아웃을 기반으로 정적 웹사이트를 생성하는 도구이다. GitHub Pages에서 공식으로 지원하며 다양한 테마가 제공된다.   Jekyll에 대한 추가 내용은 여기에서 확인할 수 있다.      GitHub.com #jekyll-theme repos   jamstackthemes.dev   jekyllthemes.org   jekyllthemes.io   jekyll-themes.com   위 링크는 Jekyll 테마 웹사이트를 제공하는 사이트 목록이다. 링크에서 원하는 Jekyll 테마를 선택한다.      테마를 선택했다면 테마의 GitHub 사이트에 접속한다.   스크린샷의 테마를 사용하려면 여기를 클릭한다.      테마의 GitHub 메인 화면에서 Code 버튼을 클릭하여 URL 정보를 복사한다.   4. 개인 저장소에 테마 저장소 복사하기      저장소 만들기 단계에서 생성한 저장소 메인 화면에서 Import code 버튼을 클릭한다.      URL 정보 입력란에 복사한 URL 정보를 입력하고 Begin import 버튼을 클릭한다.      Jekyll 테마 저장소에 있는 데이터를 개인 저장소에 복사(Clone)할 때 작업 소요 시간은 테마 용량에 따라 다르다. 커피 한잔을 음미하며 차분히 기다린다.      복사 작업이 완료되면 개인 저장소 메인 화면 -&gt; 설정(Settings) 메뉴 -&gt; 페이지 서브 메뉴에서 소스(Source) 영역에 Branch: master와 같이 설정 후 저장한다. 위 웹페이지 주소를 통해 접속할 수 있으니 즐겨찾기나 README.md에 링크를 추가하여 매번 사이트 주소를 찾는 번거로움을 줄일 수 있다.      위와 같이 웹페이지에 테마가 적용 되었다면 GitHub 블로그 만들기에 첫 걸음을 내딛는 것이다.   다른 테마를 선택하여 위 절차를 진행하는데 테마가 제대로 적용이 안되는 경우, 해당 테마의 GitHub 사이트에 별도로 설정해야 하는 절차가 있는지 확인하여 추가 절차를 진행해야 한다.    ","categories": [],
        "tags": ["Blog","Github Pages","Jekyll"],
        "url": "/20210807/",
        "teaser": "/assets/images/20210807/0_.png"
      },{
        "title": "Jekyll에 대하여",
        "excerpt":" Jekyll   지킬(Jekyll)은 동적 객체 지향 스크립트 언어인 루비(Ruby) 기반으로 개발된 하나의 라이브러리 즉 루비젬(RubyGem)이다. 루비는 인터프리터(Interpreter) 언어의 특성에 따라 C 또는 C++과 같은 컴파일러 언어에 비해 실행 속도가 느리지만 매번 HTML 태그를 작성하지 않고 콘텐츠에 초점을 맞춘 마크다운 언어(Markdown Language)로 작성하여 보다 쉽게 정적 웹사이트를 생성하는 편리한 도구이다.   Markdown에 대한 내용은 여기에서 확인할 수 있다.   파일/디렉토리 구조   Jekyll의 일반적인 파일 및 디렉토리 구조와 각 항목에 대한 설명은 다음과 같이 구성된다.   ┌─_config.yml ├─_data │  └─navigation.yml ├─_drafts │  ├─begin-with-the-crazy-ideas.md │  └─on-simplicity-in-technology.md ├─_includes │  ├─footer.html │  └─head.html ├─_layouts │  ├─default.html │  └─posts.html ├─_posts │  ├─2021-08-06-start.md │  └─2021-08-07-build.md ├─_sass │  ├─_base.scss │  └─_page.scss └─index.html # index.md도 사용 가능                  파일/디렉토리       설명                       _config.yml       파일로 환경 구성 정보를 담는다. 정적 웹사이트 생성 시 환경 구성에 활용되며, title, url 등 요소를 {{ site.title }}와 같이 Liquid 태그를 이용하여 접근할 수 있다.                 _drafts       디렉토리로 아직 게시하지 않은 초안 포스트를 담는다. 초안 포스트에 파일명은 포스트와 다르게 날짜 형식을 따르지 않는다.                 _includes       디렉토리로 재사용하기 위한 파일을 담는다. 파일 사용시 {% include 파일명 %}와 같이 Liquid 태그를 이용하여 접근할 수 있다.                 _layouts       디렉토리로 콘텐츠를 포장하는 템플릿을 담는다. 각 콘텐츠마다 YAML 형식의 머리말을 기준으로 레이아웃을 선택한다. 기본 규칙으로 default.html 템플릿을 호출한다. {{ content }}와 같이 Liquid 태그를 이용하여 접근할 수 있다.                 _posts       디렉토리로 동적 콘텐츠를 담는다. 포스트에 파일명은 YEAR-MONTH-DAY-title.MARKUP와 같이 날짜 형식으로 생성한다.                 _data       디렉토리로 사이트에서 사용할 데이터를 담는다. 디렉토리 내 .yml, .yaml, .json, .csv, .tsv 형식의 모든 데이터 파일을 자동으로 로드하고 site.data 변수로 접근할 수 있다. 디렉토리에 navigation.yml라는 파일이 있을 경우 site.data.navigation라고 입력하여 해당 콘텐츠를 사용한다.                 _sass       디렉토리로 스타일시트 조각을 담는다. 정적 웹사이트 생성 시 sass 조각들이 모여 스타일을 정의하는 하나의 main.css 파일로 가공된다.                 index.html 또는 index.md       웹사이트에 접속 시 가장 먼저 접근하는 파일이다.           환경 구성   Jekyll은 정적 웹사이트 생성 과정에서 루트 디렉토리의 _config.yml 또는 _config.toml 파일에 정의된 요소를 로드하여 웹사이트 환경을 구성한다. 아래 목록의 정의된 요소는 기본값으로 파일 내용에 정의되어 있지 않은 경우 기본값을 사용한다.   # Where things are source              : . destination         : ./_site collections_dir     : . plugins_dir         : _plugins # takes an array of strings and loads plugins in that order layouts_dir         : _layouts data_dir            : _data includes_dir        : _includes sass:   sass_dir: _sass collections:   posts:     output          : true  # Handling Reading safe                : false include             : [\".htaccess\"] exclude             : [\"Gemfile\", \"Gemfile.lock\", \"node_modules\", \"vendor/bundle/\", \"vendor/cache/\", \"vendor/gems/\", \"vendor/ruby/\"] keep_files          : [\".git\", \".svn\"] encoding            : \"utf-8\" markdown_ext        : \"markdown,mkdown,mkdn,mkd,md\" strict_front_matter : false  # Filtering Content show_drafts         : null limit_posts         : 0 future              : false unpublished         : false  # Plugins whitelist           : [] plugins             : []  # Conversion markdown            : kramdown highlighter         : rouge lsi                 : false excerpt_separator   : \"\\n\\n\" incremental         : false  # Serving detach              : false port                : 4000 host                : 127.0.0.1 baseurl             : \"\" # does not include hostname show_dir_listing    : false  # Outputting permalink           : date paginate_path       : /page:num timezone            : null  quiet               : false verbose             : false defaults            : []  liquid:   error_mode        : warn   strict_filters    : false   strict_variables  : false  # Markdown Processors kramdown:   auto_ids          : true   entity_output     : as_char   toc_levels        : [1, 2, 3, 4, 5, 6]   smart_quotes      : lsquo,rsquo,ldquo,rdquo   input             : GFM   hard_wrap         : false   footnote_nr       : 1   show_warnings     : false                  요소/설명       옵션                       Site Source Jekyll이 읽어들일 파일의 경로를 변경한다.       source: DIR                 Site Destination Jekyll이 생성할 파일의 경로를 변경한다.       destination: DIR                 Safe whitelist에 없는 플러그인을 비활성화하고 디스크에 캐싱하며, 심볼릭 링크를 무시한다.       safe: BOOL                 Exclude 특정 디렉토리나 파일을 제외하는 목록이다. Site Source를 기준으로 한 상대경로이다.       exclude: [DIR,FILE,...]                 Include 특정 디렉토리나 파일을 포함하는 목록이다. Site Source를 기준으로 한 상대경로이다.       include: [DIR,FILE,...]                 Keep Files 사이트 생성 전 Site Destination을 초기화할 때, 보관할 파일 목록이다. Jekyll에서 생성되는 않은 파일에 유용하다.       keep_files: [DIR,FILE,...]                 Time Zone 사이트 생성 시간대를 설정한다. 사용 가능한 목록은 여기에서 찾을 수 있다.       timezone: TIMEZONE                 Encoding 파일의 인코딩을 지정한다. 사용 가능한 목록은 여기에서 찾을 수 있다.       encoding: ENCODING                 Plugins 플러그인 경로를 변경한다.       plugins_dir: [DIR1,...]                 Layouts 레이아웃 경로를 변경한다.       layouts_dir: DIR                 Drafts 초안 콘텐츠를 표현한다.       show_drafts: BOOL                 Future 현재 시간 이후의 콘텐츠를 게시한다.       future: BOOL                 Unpublished 미개시로 지정된 콘텐츠를 처리한다.       unpublished: BOOL                 LSI 관련 콘텐츠에 대한 색인을 생성한다. classifier-reborn 플러그인이 필요하다.       lsi: BOOL                 Limit Posts 구문 분석 및 게시할 콘텐츠 수를 제한한다.       limit_posts: NUM                 Incremental Build 실험 기능인 증분 빌드를 활성화한다. 증분 빌드는 변경된 파일만 다시 빌드하여 대규모 사이트인 경우 성능이 크게 향상되지만 경우에 따라 사이트 생성이 중단될 수 있다.       incremental: BOOL                 Strict Front Matter 페이지의 머리말에 YAML 문법 오류가 있으면 빌드를 중단한다.       strict_front_matter: BOOL                 Base URL 지정된 URL로 웹사이트를 제공한다.       baseurl: URL                 Limit Posts 구문 분석 및 게시할 콘텐츠 수를 제한한다.       limit_posts: NUM                 Local Server Port 지정된 포트에서 수신한다.       port: PORT                 Local Server Hostname 주어진 호스트 이름에서 수신한다.       host: HOSTNAME                 Detach 터미널에서 서버를 분리한다.       detach: BOOL                 Show Directory Listing 색인 파일을 로드하는 대신 디렉토리 목록을 표시한다.       show_dir_listing: BOOL           페이지   페이지는 콘텐츠를 구성하는 가장 기본적인 요소이다. 단독 콘텐츠(날짜별로 구성되거나, 스태프 맴버 또는 레시피와 같이 그룹이 아닌 콘텐츠)를 구성하는데 유용하다.   페이지를 추가하는 방법은 루트 디렉토리 내 원하는 경로와 파일명으로 .html 또는 .md 파일을 생성한다.   ┌─page1.md      # -&gt; http://example.com/page1.html ├─pets          # folder containing pages │  └─cat.html   # -&gt; http://example.com/pets/cat.html ├─cooks         # folder containing pages │  ├─ramen.md   # -&gt; http://example.com/cooks/ramen.html │  └─curry.md   # -&gt; http://example.com/cooks/curry.html └─page2.html    # -&gt; http://example.com/page2.html   또한 특정 폴더에서 출력 URL을 제어할 수 있는 Permalinks를 활용하면 지정된 경로로 접근한다. page1.md 머리말에 permalink를 추가하면   --- permalink: /test1/test2/test3/page1/ ---   다음과 같이 page1.md의 URL이 변경됨을 확인할 수 있다.   page1.md      # -&gt; http://example.com/test1/test2/test3/page1.html   포스트   파일명   포스트는 핵심 콘텐츠로서 날짜 형식의 파일명(YEAR-MONTH-DAY-title.MARKUP)으로 작성한다. 또한 _posts 디렉토리 내 생성한다. 파일명을 예로 들면 다음과 같다.   2021-04-01-my-first-content.md 2021-08-10-hello-world.md   머리말   모든 포스트 파일은 일반적으로 레이아웃이나 다른 메타 데이터를 설정할 수 있는 머리말로 시작되어야 한다. 간단한 예로 다음과 같이 작성한다.   --- layout: post title: Hello World! ---  # Welcome  **Hello world**, this is my second blog post.  I hope you like it!   머리말에 사용 가능한 요소는 다음과 같다.                  요소명       설명                       layout       사용할 레이아웃 파일을 지정한다. _layouts 디렉토리에 있는 파일을 확장자를 제외한 파일명으로 입력한다. null 또는 레이아웃을 입력하지 않을 경우 default 레이아웃을 사용하여 파일을 처리한다. none을 사용하는 경우 레이아웃을 사용하지 않고 파일을 처리한다.                 permalink       콘텐츠에 접근하는 URL을 지정한다. 입력하지 않은 경우 디렉토리 구조를 따른다.                 published       특정 포스트가 나타나지 않게 하려면 false로 설정한다.                 date       콘텐츠에 날짜를 입력한다. 파일명에 날짜보다 우선순위가 높다. 포스트를 올바르게 정렬하기 위해 사용할 수 있는 기능이다. 날짜 형식은 YYYY-MM-DD HH:MM:SS +/-TTTT이며 시간, 분, 초, 시간대 오프셋은 선택 사항이다.                 tags       하나 이상의 태그를 지정한다. 태그별 범주를 구성할 수 있다.                 category 또는 categories       카테고리별 디렉토리에 콘텐츠를 배치하는 대신 하나 이상의 카테고리를 지정한다. 카테고리별 범주를 구성할 수 있다.           포스트 색인 생성   Liquid와 HTML 태그를 이용하여 별도의 페이지에 포스트 색인을 생성할 수 있다. 다음은 블로그 포스트 색인을 출력하는 예시이다.   &lt;ul&gt;   {% for post in site.posts %}     &lt;li&gt;       &lt;a href=\"{{ post.url }}\"&gt;{{ post.title }}&lt;/a&gt;     &lt;/li&gt;   {% endfor %} &lt;/ul&gt;   태그 및 카테고리   Liquid와 html 태그를 이용하여 별도의 페이지에 태그 및 카테고리 색인을 생성할 수 있다. 다음은 태그 및 카테고리별 블로그 포스트 색인을 출력하는 예시이다.   태그 색인 생성   {% for tag in site.tags %}   &lt;h3&gt;{{ tag[0] }}&lt;/h3&gt;   &lt;ul&gt;     {% for post in tag[1] %}       &lt;li&gt;&lt;a href=\"{{ post.url }}\"&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;     {% endfor %}   &lt;/ul&gt; {% endfor %}   카테고리 색인 생성   {% for category in site.categories %}   &lt;h3&gt;{{ category[0] }}&lt;/h3&gt;   &lt;ul&gt;     {% for post in category[1] %}       &lt;li&gt;&lt;a href=\"{{ post.url }}\"&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;     {% endfor %}   &lt;/ul&gt; {% endfor %}   포스트 발췌   기본적인 스니펫은 _config.yml에 설정된 \"\\n\\n\"이지만 머리말에 excerpt_separator 변수를 사용하여 콘텐츠의 단락을 변경할 수 있다.   --- excerpt_separator: &lt;!--more--&gt; ---  Excerpt with multiple paragraphs  Here's another paragraph in the excerpt. &lt;!--more--&gt; Out-of-excerpt   다음은 발췌와 함께 블로그 포스트 색인을 출력하는 예시이다.   &lt;ul&gt;   {% for post in site.posts %}     &lt;li&gt;       &lt;a href=\"{{ post.url }}\"&gt;{{ post.title }}&lt;/a&gt;       {{ post.excerpt }}     &lt;/li&gt;   {% endfor %} &lt;/ul&gt;   초안   초안이란 파일명에 날짜가 없는 포스트이다. 현재 작성중으로 아직은 게시하고 싶지 않은 포스트를 의미한다. 초안 기능을 사용하려면 _drafts 디렉토리 내 포스트를 작성한다.   ","categories": [],
        "tags": ["Jekyll","Static Site Generator"],
        "url": "/20210810/",
        "teaser": "/assets/images/20210810/0_.png"
      },{
        "title": "Markdown에 대하여",
        "excerpt":" Markdown   마크다운(Markdown)은 일반 텍스트 기반의 경량 마크업(Markup) 언어다. 일반 텍스트로 서식이 있는 문서를 작성하는데 사용되며, 일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징이다. HTML과 리치 텍스트(RTF) 등 서식 문서로 쉽게 변환되기 때문에 온라인 콘텐츠 등에서 .md 또는 .markdown 확장자로 사용한다.   Tips  온라인 Markdown Editor를 확인하려면 여기를 클릭한다.   Jekyll에서 지원하는 Markdown 문법의 요소는 다음과 같다.   제목                  Markdown       HTML       출력                       # Heading level 1 또는 Heading level 1 ===       &lt;h1&gt;Heading level 1&lt;/h1&gt;       Heading level 1                 ## Heading level 2 또는 Heading level 2 —       &lt;h2&gt;Heading level 2&lt;/h2&gt;       Heading level 2                 ### Heading level 3       &lt;h3&gt;Heading level 3&lt;/h3&gt;       Heading level 3                 #### Heading level 4       &lt;h4&gt;Heading level 4&lt;/h4&gt;       Heading level 4                 ##### Heading level 5       &lt;h5&gt;Heading level 5&lt;/h5&gt;       Heading level 5                 ###### Heading level 6       &lt;h6&gt;Heading level 6&lt;/h6&gt;       Heading level 6           수평선   한줄에 3개 이상의 ***, ---, ___를 사용하여 수평선을 그린다.   ***  ---  ___     단락   빈 줄을 추가하거나 &lt;p&gt;&lt;/p&gt; 태그를 이용하여 단락을 구분한다.                  Markdown       HTML                       I really like using Markdown.  I think I’ll use it to format all of my documents from now on.       &lt;p&gt;I really like using Markdown.&lt;/p&gt;&lt;p&gt;I think I’ll use it to format all of my documents from now on.&lt;/p&gt;           I really like using Markdown.  I think I'll use it to format all of my documents from now on.   줄 바꿈   두 개 이상의 띄어쓰기와 엔터(enter)를 입력하거나 &lt;br&gt; 태그를 이용하여 줄을 바꾼다.                  Markdown       HTML                       This is the first line.   And this is the second line.       This is the first line.&lt;br&gt;And this is the second line.           This is the first line.   And this is the second line.   강조   텍스트 스타일을 굵게 또는 기울임꼴로 변경한다.                  Markdown       HTML       출력                       I love *it*. 또는 I love _it_.       I love &lt;em&gt;it&lt;/em&gt;.       I love it.                 I love **it**. 또는 I love __it__.       I love &lt;strong&gt;it&lt;/strong&gt;.       I love it.                 I love ***it***. 또는 I love ___it___.       I love &lt;strong&gt;&lt;em&gt;it&lt;/em&gt;&lt;/strong&gt;.       I love it.           취소선   단어 가운데에 수평선을 넣어 취소선을 표현하려면 ~~를 단어의 앞 뒤에 사용한다.   ~~The world is flat.~~ We now know that the world is round.   The world is flat. We now know that the world is round.   인용구   문장 앞에 &gt;를 입력하여 인용구를 만든다. 인용 부호는 중첩하여 사용할 수 있으며 다른 Markdown 요소와 동시에 사용이 가능하다.   &gt; #### The quarterly results look great! &gt; &gt; - Revenue was off the chart. &gt; - Profits were higher than ever. &gt; &gt; *Everything* is going according to **plan**. &gt;&gt; But we should not forget about prudence.      * The quarterly results look great!*          Revenue was off the chart.     Profits were higher than ever.       Everything is going according to plan.         But we should not forget about prudence.       목록   순서가 지정된 목록을 만드는 방법은 문장 앞에 숫자와 마침표를 입력한다. 숫자는 1부터 입력해야 하며 다음 입력하는 숫자가 무엇이든 순서대로 목록이 지정된다. 순서가 지정되지 않은 목록을 만드는 방법은 문장 앞에 -, *, + 기호를 입력한다.                  Markdown       HTML       출력                       1. First item 2. Second item 3. Third item 4. Fourth item       &lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt; &lt;/ol&gt;       1. First item 2. Second item 3. Third item 4. Fourth item                 1. First item 1. Second item 1. Third item 1. Fourth item       &lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt; &lt;/ol&gt;       1. First item 2. Second item 3. Third item 4. Fourth item                 1. First item 8. Second item 3. Third item 5. Fourth item       &lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt; &lt;/ol&gt;       1. First item 2. Second item 3. Third item 4. Fourth item                 - First item - Second item - Third item - Fourth item       &lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt; &lt;/ol&gt;       · First item · Second item · Third item · Fourth item                 * First item * Second item * Third item * Fourth item       &lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt; &lt;/ol&gt;       · First item · Second item · Third item · Fourth item                 + First item + Second item + Third item + Fourth item       &lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt; &lt;/ol&gt;       · First item · Second item · Third item · Fourth item           블록   블록의 모든 행을 최소 4개의 띄어쓰기 또는 하나의 탭만큼 들여쓰거나 &lt;pre&gt;&lt;/pre&gt; 태그를 이용하여 코드 블록을 생성한다.       &lt;         Code Block     &gt;   &lt;pre&gt; public class OutputFunction {   public static void main(String[] args)   {      System.out.println(\"Hello, World!\");   } } &lt;/pre&gt;    public class OutputFunction {   public static void main(String[] args)   {      System.out.println(\"Hello, World!\");   } }   또다른 방법으로 단락의 앞과 뒤에 ``` 또는 ~~~ 줄을 추가하여 코드 블록을 생성한다. 시작점에 사용하는 언어를 선언하여 구문 강조(Syntax Highlighting)가 가능하다.   ```java public class OutputFunction {   public static void main(String[] args)   {      System.out.println(\"Hello, World!\");   } } ```   public class OutputFunction {   public static void main(String[] args)   {      System.out.println(\"Hello, World!\");   } }   ```json {   \"firstName\": \"John\",   \"lastName\": \"Smith\",   \"age\": 25 } ```   {   \"firstName\": \"John\",   \"lastName\": \"Smith\",   \"age\": 25 }   코드   단어나 구를 `로 감싸 코드로 표현한다.                  Markdown       HTML       출력                       At the command prompt, type `nano`.       At the command prompt, type &lt;code&gt;nano&lt;/code&gt;.       At the command prompt, type nano.           링크   링크 텍스트를 []로 묶고 바로 뒤에 URL을 ()로 묶는다.   My favorite search engine is [Google](https://google.com).   My favorite search engine is Google.   버튼   링크 뒤에 .btn 클래스를 적용한다. 8개의 스타일과 4개의 크기를 지원한다.   [Default Button Text](#link){: .btn} [Primary Button Text](#link){: .btn .btn--primary} [Success Button Text](#link){: .btn .btn--success} [Warning Button Text](#link){: .btn .btn--warning} [Danger Button Text](#link){: .btn .btn--danger} [Info Button Text](#link){: .btn .btn--info} [Inverse Button](#link){: .btn .btn--inverse} [Light Outline Button](#link){: .btn .btn--light-outline}   Default Button Text Primary Button Text Success Button Text Warning Button Text Danger Button Text Info Button Text Inverse Button Light Outline Button   [X-Large Button](#link){: .btn .btn--primary .btn--x-large} [Large Button](#link){: .btn .btn--primary .btn--large} [Default Button](#link){: .btn .btn--primary } [Small Button](#link){: .btn .btn--primary .btn--small}   X-Large Button Large Button Default Button Small Button   툴팁   URL 뒤에 툴팁 정보를 ““로 감싸 넣는다. 마우스를 링크 위로 가져가면 툴팁 정보가 나타난다.   My favorite search engine is [Google](https://google.com \"The best search engine for privacy\").   My favorite search engine is Google.   URL 및 Email 링크   URL이나 이메일 주소를 &lt;&gt;로 감싼다.   &lt;https://google.com&gt; &lt;no-reply@google.com&gt;  https://google.com  no-reply@google.com   이미지   먼저 !와 이미지 텍스트를 []로 묶고 바로 뒤에 URL을 ()로 묶는다. 추가로 툴팁 정보를 나타내려면 URL 뒤에 툴팁 정보를 ““로 감싸 넣는다. 또다른 방법으로 &lt;img/&gt; 또는 &lt;image/&gt; 태그를 이용하여 크기 조절이 가능한 이미지를 추가한다.   ![Photo Caption #1](/assets/images/20210817/1.jpg \"Ocean Sunrise Dawn Peninsula France Landscape\")  &lt;img width=\"50%\" src=\"/assets/images/20210817/1.jpg\" alt=\"Photo Caption #2\" title=\"Ocean Sunrise Dawn Peninsula France Landscape\" /&gt;         동영상   &lt;video&gt;&lt;/video&gt; 태그나 &lt;iframe&gt;&lt;/iframe&gt; 태그를 이용하여 크기 조절이 가능한 동영상을 추가한다. Liquid 태그가 지원되는 경우 youtube, vimeo, google-drive, bilibili에서 제공하는 동영상인 경우 아이디를 입력하여 동영상을 추가한다.   &lt;video width=\"100%\" height=\"100%\" controls&gt;     &lt;source src=\"/assets/images/20210817/2.mp4\" type=\"video/mp4\"&gt;     Your browser does not support the video tag. &lt;/video&gt;  &lt;iframe width=\"100%\" height=\"100%\" src=\"https://www.youtube.com/embed/HUBNt18RFbo\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;  {% include video id=\"HUBNt18RFbo\" provider=\"youtube\" %}             Your browser does not support the video tag.               이스케이프 문자   텍스트 서식을 지정하는데 사용되는 리터럴 문자를 표시하려면 문자 앞에 \\를 추가한다. 이스케이프 문자가 적용되는 리터럴 문자 목록은 다음과 같다.                  문자       이름                       \\       백슬래시                 `       백틱                 *       별표                 _       밑줄                 {}       중괄호                 []       대괄호                 &lt;&gt;       꺽쇠 괄호                 ()       괄호                 #       파운드 기호                 +       더하기 기호                 -       빼기 기호                 .       점                 !       느낌표                 |       파이프           \\* Without the backslash, this would be a bullet in an unordered list.   * Without the backslash, this would be a bullet in an unordered list.   테이블   표를 추가하려면 ---을 사용하여 각 열의 헤더를 만들고 |를 사용하여 각 열을 구분한다. 행의 양쪽 끝에 |를 추가하여 호환성을 향상시킨다. 추가로 각 열의 헤더에 왼쪽, 가운데, 오른쪽으로 :를 사용하여 텍스트 정렬을 지정한다.   | Syntax      | Description | Test Text     | | :---------- | :---------: | ------------: | | Header      | Title       | Here's this   | | Paragraph   | Text        | And more      |                  Syntax       Description       Test Text                       Header       Title       Here’s this                 Paragraph       Text       And more           작업 목록   작업 목록을 사용하여 확인란이 있는 항목 목록을 만든다. 작업 목록 항목 앞에 -와 [ ]를 공백으로 추가하고 빈 공백에 x를 입력하여 선택 항목을 지정한다.   - [x] Write the press release - [ ] Update the website - [ ] Contact the media      Write the press release   Update the website   Contact the media   각주   각주를 사용하면 문서 본문을 복잡하게 만들지 않고 참조를 추가할 수 있다. 각주를 생성할 때 각주 참조를 추가한 위치에 링크가 있는 위 첨자 번호가 나타나고 링크를 통해 페이지 하단의 각주 내용으로 이동이 가능하다. 각주 사용의 대표적인 예로 위키백과가 있다.   Here's a simple footnote,[^1] and here's a longer one.[^bignote]  [^1]: This is the first footnote.  [^bignote]: Here's one with multiple paragraphs and code.      Indent paragraphs to include them in the footnote.      `{ my code }`      Add as many paragraphs as you like.   Here’s a simple footnote,1 and here’s a longer one.2   참조                   This is the first footnote. &#8617;                  Here’s one with multiple paragraphs and code.         Indent paragraphs to include them in the footnote.         { my code }         Add as many paragraphs as you like. &#8617;           ","categories": [],
        "tags": ["Markdown Language"],
        "url": "/20210817/",
        "teaser": "/assets/images/20210817/0_.png"
      },{
        "title": "React.js에 대하여",
        "excerpt":" 블로그에 글을 쓸 땐 에디터 툴을 이용하여 작성된 글을 업로드하거나 GitHub에 직접 파일을 생성하여 글을 작성한다. 수정할 내용이 있을 경우도 같은 방법으로 글을 수정한다. 타 플랫폼처럼 글을 작성하거나 내용을 수정할 때 웹페이지에서 가능하다면 얼마나 편리할까? 라는 생각에 구글링을 하기 시작했다.   개발에 핵심 요소중 하나는 에디터의 구현이라 생각했다. 에디터는 Markdown으로 글을 작성하면 동시에 결과를 보여준다. 작성과 동시에 결과 확인이 가능하기 때문에 내용에 더욱 집중하며 글을 작성할 수 있다.   그러나 Jekyll로 개발된 이 블로그는 정적 웹사이트이기 때문에 동적으로 데이터를 표현하는 에디터를 구현할 수 없었다. 그래서 정적 웹사이트에서 동적 페이지를 구현할 순 없는지 다시 구글링을 시작했다.   그리고 찾은 답은 React.js였다.   React.js   리엑트.제이에스(React.js)는 자바스크립트(Javascript) 라이브러리의 하나로서 사용자 인터페이스1(User Interface:UI)를 만들기 위해 사용된다. React.js의 특징으로 선언형 프로그래밍2(Declarative Programming)을 제공하여 복잡한 UI를 만들 때 생기는 어려움을 줄여준다. 또한 싱글 페이지 애플리케이션(Single Page Application:SPA)이나 모바일 애플리케이션 개발에 사용된다. 다중 페이지를 개발하고자 할 때는 추가 라이브러리인 React Router를 활용하여 사용이 가능하다. React.js의 동작 방식은 다음과 같이 효율적으로 데이터 갱신(Refresh) 및 컴포넌트 렌더링(Rendering)을 수행한다.      JSX(Javascript eXtension)와 CSS(Cascading Style Sheets)로 애플리케이션의 각 상태에 대한 뷰 설계.   가상 DOM(Virtual Document Object Model:Virtual DOM)을 업데이트하고 프레임워크에서 이전 Virtual DOM과 현재 Virtual DOM 간의 데이터가 변경되는 부분 검출.   실제 DOM(Document Object Model)에서 최종 업데이트.   JSX   React.js는 Javascript와 JSX를 지원한다. HTML을 Javascript 문법으로 표현이 가능하지만 React.js에서는 Javascript 확장 문법인 JSX를 권장한다. 아래의 두 코드를 비교하여 JSX의 장점을 확인할 수 있다.   // Javascript class HelloMessage extends React.Component {   render() {     return React.createElement(       \"div\", null,       React.createElement(\"span\", null, \"Hello\"),       React.createElement(\"span\", null, this.props.name)     );   }}  ReactDOM.render(   React.createElement(HelloMessage, { name: \"Guest\" }),   document.getElementById('hello-example') );   // JSX class HelloMessage extends React.Component {   render() {     return (       &lt;div&gt;         &lt;span&gt;Hello&lt;/span&gt;         &lt;span&gt;{this.props.name}&lt;/span&gt;       &lt;/div&gt;     );   }}  ReactDOM.render(   &lt;HelloMessage name=\"Guest\" /&gt;,   document.getElementById('hello-example') );   위 코드의 결과는 동일하게 아래와 같이 출력된다.   HelloGuest   JSX 코드를 보면 HTML 문법과 같이 &lt;div&gt;&lt;/div&gt;와 &lt;span&gt;&lt;/span&gt; 태그를 이용하여 구조를 만들고 구조 안에 텍스트나 {}로 감싼 변수를 입력한다. 하지만 Javascript 코드는 태그를 이용하기 위해 React.createElement를 반복으로 사용하여 한눈에 구조가 보이지 않는다. Javascript 코드를 HTML 처럼 표현할 수 있기 때문에 용이한 개발이 가능히다. HTML과 흡사하지만, Javascript 내부에서 사용하기 때문에 다음과 같이 HTML과 다른 차이점이 있다.      HTML 요소에 class 값을 정의할 때, class라는 단어가 ECMAScript6의 클래스 문법과 겹치는 예약어이기 때문에 className으로 대체한다.   마찬가지 이유로 루프문 예약어와 겹치는 for는 htmlFor로 대체한다.   또한 요소에서 이벤트를 핸들링하는 onclick 등의 단어들은 onClick 처럼 카멜표기법으로 표기한다.   기존의 HTML에서 주석은 &lt;!-- code --&gt;로 사용하나 /* code */로 대체한다.   HTML Custom-Element는 &lt;my_element&gt;와 같이 사용하나 &lt;MyElement /&gt;와 같이 Pascal Case로 표기한다. 닫는 태그에는 명시적으로 /&gt; 표기한다.   JSX 내부에서도 JS를 사용할 수 있다. {console.log('ok')}와 같이 표기한다.   JSX를 빌드할 때 자바스크립트 컴파일러(Javascript Compiler)인 바벨(Babel)에서 코드 변환 처리를 수행하여 Javascript로 변환된다.   Tips  JSX를 컴파일한 Javascript 코드를 확인하려면 여기를 클릭한다.   준비 사항      NPM(Node Package Manager)3(Include Node.JS)   Babel Compiler(Include Node.JS)   Node.JS   Visual Studio Code4   설치 및 실행      Node.JS 와 VS Code를 설치한다.   window + R 키를 누르고 cmd를 입력하여 명령 프롬프트를 실행한다.    원하는 경로에서 npx create-react-app 폴더명을 입력한뒤 Enter 키를 누른다.    다운로드가 완료되면 위와 같이 폴더명 내 React 관련 데이터를 확인할 수 있다.    VS Code를 실행한 뒤 폴더 열기를 눌러 입력한 폴더(ex: react_projects)를 선택한다.    ctrl + ` 키를 눌러 터미널을 활성화하고 npm start를 입력한다.    위와 같이 브라우저에 React 로고가 보이면 React를 사용하기 위한 환경 구성이 완료된다.    참조                  사용자 인터페이스: 사용자가 조작하는 애플리케이션의 입력이나 입력에 따른 결과의 출력에 디자인을 적용하여 사용자가 애플리케이션과 상호작용을 위한 영역. &#8617;                  선언형 프로그래밍: 프로그래밍 패러다임(Programming paradigm) 중의 하나로 무엇(What)을 작업하기 위한 방법을 정의하는 것을 의미. 즉 제어 흐름을 설명하지 않고 계산 논리에 집중하여 동일한 코드를 다른 영역이나 애플리케이션에서 재사용하기 쉬움. &#8617;                  NPM: 자바스크립트 프로그래밍 언어를 위한 패키지 관리자. &#8617;                  Visual Studio Code: 편리한 React 프로그래밍을 위한 추천 도구. &#8617;           ","categories": [],
        "tags": ["React.js","JSX","UI"],
        "url": "/20210907/",
        "teaser": "/assets/images/20210907/0_.png"
      },{
        "title": "영상처리(Image Processing)",
        "excerpt":"     입력 받은 영상을 사용 목적에 맞게 적절하게 처리하여 보다 개선된 영상을 생성하는 것   입력 영상에 있는 잡음(noise) 제거, 영상의 대비(contrast) 개선, 관심영역(region of interest) 강조, 영역 분할(segmentation), 입축 및 저장 등   저수준 영상 처리(좁은 의미의 영상 처리)            영상 획득       영상 향상       영상 복원       변환 처리       영상 압축           고수준 영상 처리(컴퓨터 비전)            영상 분할       영상 표현       영상 인식           영상처리의 역사      영상처리의 시작            1920년대 초반 런던과 뉴욕 간에 해저 케이블을 통한 신문사들이 사진 전송           본격적인 영상 처리 위한 기술            1940년대 폰 노이만의 디지털 컴퓨터의 개념 시작       1950년 이후 트랜지스터, IC, 마이크로프로세서 같은 하드웨어 발달       1950 ~ 60년대 프로그램 언어의 발달과 운영체제 등의 소프트웨어 기술 발달           본격적인 영상 처리 시작            우주 탐사 계획인 아폴로 계획과도 관련, 우주선에서 보낸 훼손된 영상의 복원 연구           1970년대 영상 처리 분야 더욱 발전            CT, MRI 등의 의료 분야       원격 자원 탐사, 우주 항공 관련 분야           1990년대 컴퓨터 비전과 응용 분야 급속히 확장            인터넷 시대에 영상검색, 영상전송, 영상광고       디지털 방송 관련 컴퓨터 그래픽스, 디지털 카메라 보급           영상처리 응용 분야      의료 분야(방사선, 초음파            컴퓨터 단층 촬영(CT), 자기 공명 영상(MRI)       양전자 단층 촬영(PET)                 방송 통신 분야            디지털 방송 서비스로 인한 영상처리 기술 발달       스포츠 방송 분야에 영상 처리 기술 적용, 가상 광고 분야                 공장 자동화 분야            산업용 카메라로 제품 품질 모니터링 및 불량 제거                 기상 및 지질 탐사 분야            방대한 기상 정보를 이용의 시각화       다양한 주파수의 사진들을 영상 처리 기술로 표현                 애니메이션 및 게임 분야            촬영된 영상과 그래픽 기술이 조합       현실감 향상                 출판 및 사진 분야            영상 생성, 품질 향상, 색상을 조작 등의 작업을 위해 영상 처리 기술 사용       기존 영상에 영상 처리 기술을 융합하여 새로운 합성 영상              컴퓨터 비전 처리 단계         전처리 단계            주로 영상처리 기술 사용       다양한 특징 추출 : 엣지(edge), 선분, 영역, SIFT(Scale-Invariant Feature Transform) 등           고수준 처리            특징 정보를 사용하여 영상을 해석, 분류, 상황 묘사 등 정보 생성           화소(Pixel, 畵素)      디지털 영상을 표현하는 2차원 배열에서 각 원소   해당 위치에서 빛의 세기에 대응하는 값            0은 검은색을 나타내고, 화소값이 커질수록 밝은색           컬러 영상            R(red), G(green), B(blue) 세 가지 색상에 대한 화소 정보 표현       3개의 값을 가진 2차원 행렬로 표현           화소를 처리하는 것이 영상 처리의 시작   이미지와 색공간      색 : 빛에서 주파수(파장)의 차이에 따라 다르게 느껴지는 색상   가시광선 : 전자기파 중에서 인간이 인지할 수 있는 약 380nm ~ 780nm 사이의 파장         0 ~ 255 사이의 값으로 밝기를 표현   color : 3차원(true color 라고도 불림)             gray scale : 2차원            0 ~ 255의 값을 통해 밝기를 표현       0으로 갈수록 어두워지고, 255로 갈수록 밝아짐                 이미지 파일 형식      BMP            픽셀 데이터를 압축하지 않은 상태로 저장       파일 구조 간단하지만 용량이 매우 큼           JPG(JPEG)            손실 압축(lossy compression) 사용       원본 영상으로부터 픽셀값이 미세하게 달라짐       파일 용량 크기가 크게 감소하는 이점       디지털 카메라           GIF            무손실 압축(losses compression)       움직이는 그림인 Animation GIF 지원       256 이하의 색상을 가진 영상만을 저장하고, 화질이 매우 떨어짐           PNG            Portable Network Graphics       무손실 압축 사용       용량은 큰 편이지만 픽셀값이 변경되지 않음       α 채널을 지원하여 일부분을 투명하게 설정 가능           OpenCV      실시간 컴퓨터 비전을 목적으로 인텔(Intel)에서 개발   실시간 이미지 프로세싱에 중점을 둔 한 프로그래밍 라이브러리   TensorFlow, PyTorch 및 Caffe의 딥러닝 프레임워크 지원      이미지 읽기/쓰기      이미지는 배열로 표현 가능(Numpy)   이미지 읽기(PIL)      pillow, matplotlib와 OpenCV 모두 가능   구글 코랩(Colab), 주피터 노트북과 같은 환경에서는 pillow(PIL), matplotlib이 더 적합   OpenCV는 주로 파이썬 스크립트 환경에서 사용            from google.colab.patches import cv2_imshow으로 이미지는 출력할 수 있지만 동영상 관련 처리 불가           import cv2 import numpy as np import matplotlib.pyplot as plt %matplotlib inline  from PIL import Image import requests from io import BytesIO    url = 'https://vrthumb.imagetoday.co.kr/2019/11/19/twi001t2920297.jpg'  response = requests.get(url) pic = Image.open(BytesIO(response.content))    이미지 출력(PIL)      타입(type) 확인   PIL 이미지를 array형으로 형변환            np.asarray()           pic      type(pic)   PIL.JpegImagePlugin.JpegImageFile   pic_arr = np.asarray(pic)   type(pic_arr)   numpy.ndarray   pic_arr.shape   (340, 604, 3)   pic_arr   array([[[217, 175, 177],         [218, 176, 180],         [219, 177, 181],         ...,         [159, 119, 146],         [159, 119, 146],         [160, 117, 145]],         [[218, 176, 178],         [219, 177, 179],         [220, 178, 180],         ...,         [154, 114, 141],         [154, 114, 141],         [152, 112, 139]],         [[216, 174, 175],         [217, 175, 176],         [218, 176, 177],         ...,         [153, 112, 142],         [153, 112, 142],         [151, 110, 140]],         ...,         [[ 33, 139, 187],         [ 61, 168, 210],         [ 80, 176, 237],         ...,         [170, 212, 237],         [137, 195, 219],         [105, 186, 205]],         [[185, 208, 252],         [161, 211, 244],         [ 89, 166, 208],         ...,         [179, 207, 244],         [162, 200, 239],         [118, 183, 225]],         [[101, 173, 197],         [ 67, 149, 170],         [ 38, 121, 163],         ...,         [ 85, 175, 209],         [144, 200, 233],         [149, 205, 232]]], dtype=uint8)   이미지 출력(matplotlib)      R, G, B 에 따라 이미지 확인   채널 순서 (R G B : 0 1 2)            R channel       G channel       B channel           plt.imshow(pic_arr) plt.show()      pic_copy = pic_arr.copy() plt.imshow(pic_copy) plt.show()      pic_copy.shape   (340, 604, 3)   print(pic_copy[:,:,0]) print(pic_copy[:,:,0].shape)   [[217 218 219 ... 159 159 160]  [218 219 220 ... 154 154 152]  [216 217 218 ... 153 153 151]  ...  [ 33  61  80 ... 170 137 105]  [185 161  89 ... 179 162 118]  [101  67  38 ...  85 144 149]] (340, 604)   Red   plt.imshow(pic_copy[:,:,0]) plt.show()      plt.imshow(pic_copy[:,:,0], cmap='gray') plt.show()      Green   print(pic_copy[:,:,1]) print(pic_copy[:,:,1].shape)   [[175 176 177 ... 119 119 117]  [176 177 178 ... 114 114 112]  [174 175 176 ... 112 112 110]  ...  [139 168 176 ... 212 195 186]  [208 211 166 ... 207 200 183]  [173 149 121 ... 175 200 205]] (340, 604)   plt.imshow(pic_copy[:,:,1], cmap='gray') plt.show()      Blue   print(pic_copy[:,:,2]) print(pic_copy[:,:,2].shape)   [[177 180 181 ... 146 146 145]  [178 179 180 ... 141 141 139]  [175 176 177 ... 142 142 140]  ...  [187 210 237 ... 237 219 205]  [252 244 208 ... 244 239 225]  [197 170 163 ... 209 233 232]] (340, 604)   plt.imshow(pic_copy[:,:,2], cmap='gray') plt.show()      pic_red = pic_arr.copy() pic_red[:,:,1] = 0 pic_red[:,:,2] = 0   pic_red   array([[[217,   0,   0],         [218,   0,   0],         [219,   0,   0],         ...,         [159,   0,   0],         [159,   0,   0],         [160,   0,   0]],         [[218,   0,   0],         [219,   0,   0],         [220,   0,   0],         ...,         [154,   0,   0],         [154,   0,   0],         [152,   0,   0]],         [[216,   0,   0],         [217,   0,   0],         [218,   0,   0],         ...,         [153,   0,   0],         [153,   0,   0],         [151,   0,   0]],         ...,         [[ 33,   0,   0],         [ 61,   0,   0],         [ 80,   0,   0],         ...,         [170,   0,   0],         [137,   0,   0],         [105,   0,   0]],         [[185,   0,   0],         [161,   0,   0],         [ 89,   0,   0],         ...,         [179,   0,   0],         [162,   0,   0],         [118,   0,   0]],         [[101,   0,   0],         [ 67,   0,   0],         [ 38,   0,   0],         ...,         [ 85,   0,   0],         [144,   0,   0],         [149,   0,   0]]], dtype=uint8)   plt.imshow(pic_red) plt.show()      pic_green = pic_arr.copy() pic_green[:,:,0] = 0 pic_green[:,:,2] = 0 plt.imshow(pic_green) plt.show()      pic_blue = pic_arr.copy() pic_blue[:,:,0] = 0 pic_blue[:,:,1] = 0 plt.imshow(pic_blue) plt.show()      이미지 출력(OpenCV)      from google.colab.patches import cv2_imshow            원래는 cv2.imshow           from google.colab.patches import cv2_imshow   cv2_imshow(pic_arr)      OpenCV의 채널 순서      OpenCV를 통해 영상(이미지)을 다룰 때의 채널 순서는 B G R   matplotlib은 R G B 순서   cv2.cvtColor()      image array, 변경할 색공간을 인자로 넣어줌   변경할 색공간은 여러가지가 있음            cv2.COLOR_BGR2RGB       cv2.COLOR_RGB2GRAY       cv2.COLOR_GRAY2RGB           (참고)array[:,:,::-1]을 통해서도 인덱스 순서를 바꿀 수 있음   image = cv2.cvtColor(pic_arr, cv2.COLOR_RGB2BGR) cv2_imshow(image)      print(image[0][0]) print(pic_arr[0][0])   [177 175 217] [217 175 177]   temp_arr = pic_arr[:,:,::-1] print(pic_arr[0][0]) print(temp_arr[0][0])   [217 175 177] [177 175 217]   이미지 읽기(OpenCV)   cv2.imread()      path, 이미지 파일의 flag값을 인자로 넣어줌   cv2.IMREAD_COLOR: 이미지 파일을 Color로 읽어들이고, 투명한 부분은 무시되며, Default 값   cv2.IMREAD_GRAYSCALE: 이미지를 Grayscale로 읽음. 실제 이미지 처리시 중간단계로 많이 사용   cv2.IMREAD_UNCHANGED: 이미지 파일을 alpha channel(투명도)까지 포함하여 읽어 드림   (주의) cv2.imread()는 잘못된 경로로 읽어도 NoneType으로 들어갈 뿐, 오류를 발생하지 않음   !wget -O lion.jpg https://cdn.pixabay.com/photo/2017/10/25/16/54/african-lion-2888519__480.jpg   --2021-10-25 09:48:34--  https://cdn.pixabay.com/photo/2017/10/25/16/54/african-lion-2888519__480.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.21.183, 104.18.20.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.21.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 65101 (64K) [image/jpeg] Saving to: ‘lion.jpg’  lion.jpg            100%[===================&gt;]  63.58K  --.-KB/s    in 0.01s     2021-10-25 09:48:34 (5.16 MB/s) - ‘lion.jpg’ saved [65101/65101]   img = cv2.imread('/content/lion.jpg', cv2.IMREAD_UNCHANGED) print(type(img))   &lt;class 'numpy.ndarray'&gt;   cv2_imshow(img)      plt.imshow(img) plt.show()      img_temp = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) plt.imshow(img_temp) plt.show()      img_gray = cv2.imread('/content/lion.jpg', cv2.IMREAD_GRAYSCALE)   print(img_gray.shape)   (480, 644)   cv2_imshow(img_gray)      plt.imshow(img_gray) plt.show()      plt.imshow(img_gray, cmap='gray') plt.show()      plt.imshow(img_gray, cmap='magma') plt.show()      이미지 쓰기   cv2.imwrite()      경로, 이미지 배열을 인자로 받음   이미지 저장을 하면 True 반환   없는 이미지를 읽어도 type이 NoneType으로 들어갈 뿐 에러를 발생하지 않음   random_img = np.random.randint(0, 256, size=(200, 200, 3)) print(random_img.shape)   (200, 200, 3)   cv2.imwrite('./random_img.png', random_img)   True   my_img = cv2.imread('/content/random_img.png')   print(type(my_img)) print(my_img.shape)   &lt;class 'numpy.ndarray'&gt; (200, 200, 3)   cv2_imshow(my_img)      도형 그리기      다양한 도형을 그릴 수 있음   도형을 그리는 좌표가 해당 범위를 넘어가면 이미지에 표현되지 않음   얼굴 검출 알고리즘: 영상 위에 검출한 얼굴 영역을 사각형이나 원으로 표시    차선 검출 알고리즘: 차선을 정확하게 검출했는지 확인하기 위해 도로 영상 위에 선으로 표시    img = np.zeros((512,512,3), np.uint8)   plt.imshow(img) plt.show()      직선(Line) 그리기   cv.line()                  파라미터       설명                       img       그림을 그릴 이미지                 start       시작 좌표                 end       종료 좌표                 color       BGR 형태의 Color(e.g., (255,0,0)-&gt;Blue)                 thickness(int)       선 두께(pixel)           img = cv2.line(img, (0,0),(511,511),(255,0,0),5) plt.imshow(img) plt.show()      사각형(Reatangle) 그리기   cv.rectangle()                  파라미터       설명                       img       그림을 그릴 이미지                 start       시작 좌표                 end       종료 좌표                 color       BGR 형태의 Color                 thickness       선 두께(pixel)           img = cv2.rectangle(img, (400,0),(510,100),(0,255,0),3) plt.imshow(img) plt.show()      원(Circle) 그리기   cv.circle()                  파라미터       설명                       img       그림을 그릴 이미지                 center       원의 중심 좌표(x,y)                 radian       반지름                 color       BGR 형태의 Color                 thickness       선 두께, -1이면 원 안쪽을 채움                 lineType       선의 형태, cv.line() 함수의 인수와 동일                 shift       좌표에 대한 비트 시프트 연산           img = cv2.circle(img, (450,50), 50, (0,0,255), -1) plt.imshow(img) plt.show()      img = cv2.circle(img, (50,450), 50, (0, 255, 255), 2) plt.imshow(img) plt.show()      타원(Ellipse) 그리기   cv.ellipse()                  파라미터       설명                       img       그림을 그릴 이미지                 center       원의 중심 좌표(x,y)                 axes       중심에서 가장 큰 거리와 작은 거리                 angle       타원의 기울기 각                 startAngle       타원의 시작 각도                 endAngle       타원이 끝나는 각도                 color       타원의 색                 thickness       선 두께, -1이면 원 안쪽을 채움                 lineType       선의 형태                 shift       좌표에 대한 비트 시프트           img = cv2.ellipse(img, (256,256), (150,30), 0, 0, 180, (0,255,0), -1) plt.imshow(img) plt.show()      img = cv2.ellipse(img, (256,256), (150,50), 45, 0, 360, (255,255,255), 2) plt.imshow(img) plt.show()      img = cv2.ellipse(img, (256,256), (150,10), 135, 0, 270, (0,0,255), 2) plt.imshow(img) plt.show()      pts = np.array([[10,5], [20,30], [70,20], [50,10]], np.int32) print(pts.shape) pts   (4, 2)      array([[10,  5],        [20, 30],        [70, 20],        [50, 10]], dtype=int32)   pts = pts.reshape((-1, 2, 1)) print(pts.shape) pts   (4, 2, 1)      array([[[10],         [ 5]],         [[20],         [30]],         [[70],         [20]],         [[50],         [10]]], dtype=int32)   다각형(Polygon) 그리기   cv.polylines()                  파라미터       설명                       img       그림을 그릴 이미지                 pts(array)       연결할 꼭지점 좌표                 isClosed       닫힌 도형 여부                 color       다각형의 색                 thickness       선 두께              이미지에 표현하기 위해 점 좌표를 3차원 행렬로 변환            변환 이전과 이후의 행렬 갯수는 동일해야함       -1은 원본에 해당하는 값을 그대로 유지           img = cv2.polylines(img, [pts], True, (0, 150, 250), 4) plt.imshow(img) plt.show()      pts2 = np.array([[150,5], [200,30], [100,70], [50,20]], np.int32) print(pts2.shape) pts = pts.reshape((-1, 2, 1)) print(pts.shape) pts   (4, 2) (4, 2, 1)      array([[[10],         [ 5]],         [[20],         [30]],         [[70],         [20]],         [[50],         [10]]], dtype=int32)   img = cv2.polylines(img, [pts2], True, (172, 200, 255), 4) plt.imshow(img) plt.show()      텍스트(Text) 그리기   cv.putText()                  파라미터       설명                       img       그림을 그릴 이미지                 text       표시할 문자열                 org       문자열이 표시될 위치. 문자열의 bottom-left corner 점                 fontFace       폰트 타입. CV2.FONT_XXX                 fontScale       폰트 크기                 color       폰트 색                 thickness       글자의 굵기                 lineType       글자 선의 형태                 bottomLeftOrigin       영상의 원점 좌표 설정(True: 좌하단, False: 좌상단)              문자열 폰트 옵션                  옵션       값       설명                       cv2.FONT_HERSHEY_SIMPLEX       0       중간 크기 산세리프 폰트                 cv2.FONT_HERSHEY_PLANIN       1       작은 크기 산세리프 폰트                 cv2.FONT_HERSHEY_DUPLEX       2       2줄 산세리프 폰트                 cv2.FONT_HERSHEY_COMPLEX       3       중간 크기 세리프 폰트                 cv2.FONT_HERSHEY_TRIPLEX       4       3줄 세리프 폰트                 cv2.FONT_HERSHEY_COMPLEX_SMALL       5       COMPLEX 보다 작은 크기                 cv2.FONT_HERSHEY_SCRIPT_SIMPLEX       6       필기체 스타일 폰트                 cv2.FONT_HERSHEY_SCRIPT_COMPLEX       7       복잡한 필기체 스타일                 cv2.FONT_ITALIC       16       이탤릭체를 위한 플레그           img = cv2.putText(img, 'OpenCV', (10,500), cv2.FONT_HERSHEY_SIMPLEX, 4, (255,255,255),3) plt.imshow(img) plt.show()      컬러 매핑(Color Mapping)      주로 그레이 스케일(Grayscale), 트루 컬러(True Color, RGB) 이미지를 많이 활용   다양한 색 공간(ex, HSV, YCrCB 등)이 존재하고 이들을 변환할 수 있음   컬러 영상 처리에서 HSV와 HSL은 같은 색 공간을 이용하여 색상 구분에 용이하고, YCrCB와 YUV`는 휘도 성분 구분에 용이   cv2.cvtColor() 활용   색 공간의 종류(참고)      RGB            컬러 표현을 빛의 3원색인 빨강(Red), 초록(Green), 파랑(Blue)으로 서로 다른 비율을 통해 색 표현       가산 혼합(additive mixture): 빛을 섞을 수록 밝아짐       모니터, 텔레비전, 빔 프로젝터와 같은 디스플레이 장비들에서 기본 컬러 공간으로 사용           CMYK            청록색(Cyan), 자홍색(Magenta), 노랑색(Yellow), 검은색(Black)을 기본으로 하여 주로 컬러 프린트나 인쇄시에 사용 감산 혼합(subtractive mixture): 섞을 수록 어두워지는 방식       RGB 컬러 공간과 보색 관계                 YUV            Y축은 밝기 성분을 U,V 두축을 이용하여 색상을 표현       U축은 파란색에서 밝기 성분을 뺀 값, V축은 빨간색에서 밝기 성분을 뺀 값       아날로그 컬러신호 변환에 주로 사용. (U=B-Y), (V=R-Y)           YCbCr            Digital TV에서 사용하는 색공간       YPbPr이라는 아날로그 신호의 색공간을 디지털화한 것       YPbPr은 아날로그 컴포넌트 비디오에서 사용           RBG Color Space      디지털 컬러 영상을 획득할 때 사용   보편적으로 사용되고 있지만 컬러 영상 처리에서는 주로 사용되지 않음      !wget -O dog.jpg http://image.dongascience.com/Photo/2017/03/14900752352661.jpg   --2021-10-25 09:48:38--  http://image.dongascience.com/Photo/2017/03/14900752352661.jpg Resolving image.dongascience.com (image.dongascience.com)... 211.43.210.30 Connecting to image.dongascience.com (image.dongascience.com)|211.43.210.30|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 61914 (60K) [image/jpeg] Saving to: ‘dog.jpg’  dog.jpg             100%[===================&gt;]  60.46K  78.7KB/s    in 0.8s      2021-10-25 09:48:40 (78.7 KB/s) - ‘dog.jpg’ saved [61914/61914]   origin_img = cv2.imread('/content/dog.jpg') print(origin_img.shape)   (447, 670, 3)      OpenCV와 matplotlib의 색공간 순서가 다르기 때문에 생기는 문제            matplotlib : R G B       OpenCV : B G R           plt.imshow(origin_img) plt.show()      img_rgb = cv2.cvtColor(origin_img, cv2.COLOR_BGR2RGB) plt.imshow(img_rgb) plt.show()      HSV Color Space      색상(hue), 채도(saturation), 명도(value)로 색을 표현   색상은 흔히 빨간색, 노란색 등과 같은 색의 종류   채도는 색의 순도            파란색에서 채도가 높으면 맑고 선한 파란색       파란색에서 채도가 낮으면 탁한 파란색           명도는 빛의 세기            명도가 높으면 밝고, 낮으면 어둡게 느껴진다.           OpenCV에서 BGR2HSV 색 공간 변환할 경우,            H : 0 ~ 179 사이의 정수로 표현                    색상 값은 0° ~ 360°로 표현하지만 uchar 자료형은 256이상의 정수를 표현할 수 없기 때문에 OpenCV에서는 각도를 2로 나눈 값을 H로 저장                       S : 0 ~ 255 사이의 정수로 표현       V : 0 ~ 255 사이의 정수로 표현              img_hsv = cv2.cvtColor(origin_img, cv2.COLOR_BGR2HSV) plt.imshow(img_hsv) plt.show()      print(np.max(img_hsv), np.min(img_hsv)) print(np.max(img_hsv[:,0,0])) print(np.min(img_hsv[:,0,0]))   255 0 101 14   HSL Color Space      색상(hue), 채도(saturation), 밝기(lightness)로 색을 표현하는 방식   HSV와 동일하지만 밝기 요소의 차이   HSV와 더불어 사람이 실제로 color를 인지하는 방식과 유사      img_hsl = cv2.cvtColor(origin_img, cv2.COLOR_BGR2HLS) plt.imshow(img_hsl) plt.show()      print(np.max(img_hsl), np.min(img_hsl)) print(np.max(img_hsl[:,0,0])) print(np.min(img_hsl[:,0,0]))   255 0 101 14   YCbCr Color Space      Y 성분은 밝기 또는 휘도(luminance), Cb, Cr 성분은 색상 또는 색차(chrominance)를 나타냄   Cb, Cr은 오직 색상 정보만 가지고 있음, 밝기 정보 X   영상을 GrayScale 정보와 색상 정보로 분리하여 처리할 때 유용   Y, Cb, Cr : 0 ~ 255 사이의 정수로 표현       img_ycbcr = cv2.cvtColor(origin_img, cv2.COLOR_BGR2YCrCb) plt.imshow(img_ycbcr) plt.show()      print(np.max(img_ycbcr), np.min(img_ycbcr)) print(np.max(img_ycbcr[:,0,0])) print(np.min(img_ycbcr[:,0,0]))   250 13 221 40   GrayScale Color Space      영상의 밝기 정보를 256단계(0 ~ 255)로 구분하여 표현   가장 밝은 흰색 : 255   가장 어두운 검은색 : 0      img_gray = cv2.cvtColor(origin_img, cv2.COLOR_BGR2GRAY) plt.imshow(img_gray, cmap='gray') plt.show()      print(np.max(img_gray), np.min(img_gray)) print(np.max(img_gray[:,0])) print(np.min(img_gray[:,0]))   250 13 221 40   히스토그램(Histogram)      이미지의 밝기의 분포를 그래프로 표현한 방식   이미지의 전체를 밝기 분포와 채도(밝고 어두움)을 알 수 있음         용어 설명      BINS            히스토그램 그래프의 X축의 간격       위 그림의 경우에는 0 ~ 255를 표현하였기 때문에 BINS 값은 256이 된다. BINS 값이 16이면 0 ~ 15, 16 ~ 31…, 240 ~ 255와 같이 X축이 16개로 표현       OpenCV에서는 BINS를 histSize 라고 표현           DIMS            이미지에서 조사하고자하는 값을 의미       빛의 강도를 조사할 것인지, RGB 값을 조사할 것인지를 결정           RANGE            측정하고자하는 값의 범위           cv2.calcHist()                                  파라미터           설명                                           image           분석대상 이미지(uint8 or float32 type). Array 형태                             channels           분석 채널(X축의 대상), 이미지가 grayscale이면 [0], color 이미지이면 [0],[0,1] 형태(1: Blue, 2: Green, 3: Red)                             mask           이미지의 분석 영역. None이면 전체 영역                             histSize           BINS 값. [256]                             ranges           Range 값. [0,256]                           !wget -O img1.jpg http://www.dailygaewon.com/news/photo/202105/11330_11828_3159.jpg !wget -O img2.jpg http://image.kmib.co.kr/online_image/2020/0927/611718110015050456_1.jpg   --2021-10-25 09:48:41--  http://www.dailygaewon.com/news/photo/202105/11330_11828_3159.jpg Resolving www.dailygaewon.com (www.dailygaewon.com)... 121.125.77.145 Connecting to www.dailygaewon.com (www.dailygaewon.com)|121.125.77.145|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 187985 (184K) [image/jpeg] Saving to: ‘img1.jpg’  img1.jpg            100%[===================&gt;] 183.58K   240KB/s    in 0.8s      2021-10-25 09:48:43 (240 KB/s) - ‘img1.jpg’ saved [187985/187985]  --2021-10-25 09:48:43--  http://image.kmib.co.kr/online_image/2020/0927/611718110015050456_1.jpg Resolving image.kmib.co.kr (image.kmib.co.kr)... 211.110.12.154 Connecting to image.kmib.co.kr (image.kmib.co.kr)|211.110.12.154|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 151740 (148K) [image/jpeg] Saving to: ‘img2.jpg’  img2.jpg            100%[===================&gt;] 148.18K   265KB/s    in 0.6s      2021-10-25 09:48:45 (265 KB/s) - ‘img2.jpg’ saved [151740/151740]   img1 = cv2.imread('/content/img1.jpg', 0) img2 = cv2.imread('/content/img2.jpg', 0)  hist1 = cv2.calcHist([img1], [0], None, [256], [0,256]) hist2 = cv2.calcHist([img2], [0], None, [256], [0,256])   plt.figure(figsize=(12,8)) plt.subplot(221) plt.imshow(img1, 'gray') plt.title('img1')  plt.subplot(222) plt.imshow(img2, 'gray') plt.title('img2')  plt.subplot(223) plt.plot(hist1, color='r') plt.plot(hist2, color='g') plt.xlim([0,256]) plt.title('histogram')  plt.show()      Mask를 적용한 히스토그램   img = img1.copy() print(img.shape)   (403, 600)   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  mask = np.zeros(img.shape[:2], np.uint8) mask[180:300,260:400] = 255 masked_img = cv2.bitwise_and(img, img, mask=mask)  hist_full = cv2.calcHist([img], [1], None, [256], [0,256]) hist_mask = cv2.calcHist([img], [1], mask, [256], [0,256])   plt.figure(figsize=(10,10)) plt.subplot(221) plt.imshow(img) plt.title('Original Image')  plt.subplot(222) plt.imshow(mask, 'gray') plt.title('Mask')  plt.subplot(223) plt.imshow(masked_img) plt.title('Masked Image')  plt.subplot(224) plt.title('Histogram') plt.plot(hist_full, color='r') plt.plot(hist_mask, color='b') plt.xlim([0,256])  plt.show()      히스토그램 평탄화      이미지의 히스토그램이 특정 영역에 너무 집중되어 있으면 contrast 가 낮아 좋은 이미지라고 할 수 없음   전체 영역에 골고루 분포가 되어 있을 때 좋은 이미지라고 할 수 있는데, 아래 히스토그램을 보면 좌측 처럼 특정 영역에 집중되어 있는 분포를 오른쪽 처럼 골고루 분포하도록 하는 작업을 Histogram Equalization 이라고 함   (참고) 이론적인 방법            이미지의 각 픽셀의 cumulative distribution(cdf)값을 구하고 Histogram Equalization 공식에 대입하여 0 ~ 255 사이의 값으로 변환       위 식으로 구해진 값을 이미지 표현하면 균일화된 이미지를 얻을 수 있음                  Numpy를 활용하여 균일화 작업   !wget -O img.jpg https://cdn.pixabay.com/photo/2021/10/14/13/50/book-6709160_960_720.jpg   --2021-10-25 09:48:46--  https://cdn.pixabay.com/photo/2021/10/14/13/50/book-6709160_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 84200 (82K) [image/jpeg] Saving to: ‘img.jpg’  img.jpg             100%[===================&gt;]  82.23K  --.-KB/s    in 0.01s     2021-10-25 09:48:46 (6.22 MB/s) - ‘img.jpg’ saved [84200/84200]   img = cv2.imread('/content/img.jpg', 0) print(img.shape)   (562, 960)   hist, bins = np.histogram(img.flatten(), 256, [0,256]) cdf = hist.cumsum() cdf_m = np.ma.masked_equal(cdf, 0) cdf_m = (cdf_m - cdf_m.min()) * 255 / (cdf_m.max() - cdf_m.min()) cdf = np.ma.filled(cdf_m, 0).astype('uint8')   img2 = cdf[img]  plt.figure(figsize=(10,8))  plt.subplot(121) plt.imshow(img, 'gray') plt.title('Original')  plt.subplot(122) plt.imshow(img2, 'gray') plt.title('Equalization')  plt.show()         OpenCV 함수로 간단하게 처리   img = cv2.imread('/content/img.jpg', 0) print(img.shape)   (562, 960)   img2 = cv2.equalizeHist(img)  plt.figure(figsize=(10,8))  plt.subplot(121) plt.imshow(img, 'gray') plt.title('Original')  plt.subplot(122) plt.imshow(img2, 'gray') plt.title('Equalization')  plt.show()      CLAHE(Contrast Limited Adaptive Histogram Equalization)      지금까지의 처리는 이미지의 전체적인 부분에 균일화를 적용   일반적인 이미지는 밝은 부분과 어두운 부분이 섞여 있기 때문에 전체에 적용하는 것은 그렇게 유용하지 않음   !wget -O img.jpg https://cdn.pixabay.com/photo/2015/08/13/01/00/keyboard-886462_960_720.jpg   --2021-10-25 09:48:47--  https://cdn.pixabay.com/photo/2015/08/13/01/00/keyboard-886462_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 54655 (53K) [image/jpeg] Saving to: ‘img.jpg’  img.jpg             100%[===================&gt;]  53.37K  --.-KB/s    in 0.01s     2021-10-25 09:48:47 (4.87 MB/s) - ‘img.jpg’ saved [54655/54655]   img = cv2.imread('/content/img.jpg', 0) print(img.shape)   (540, 960)   img2 = cv2.equalizeHist(img)  plt.figure(figsize=(10,8))  plt.subplot(121) plt.imshow(img, 'gray') plt.title('Original')  plt.subplot(122) plt.imshow(img2, 'gray') plt.title('Equalization')  plt.show()         위 결과에서 밝은 부분은 균일화가 적용되어 어두워졌지만, 일부 이미지 영역은 너무 어두워짐   이문제를 해결하기 위해서 adaptive histogram equalization을 적용하게 됨            즉, 이미지를 작은 tile 형태로 나누어 그 tile 안에서 Equalization을 적용하는 방식       작은 영역이다 보니 작은 노이즈(극단적으로 어둡거나, 밝은 영역)가 있으면 이것이 반영이 되어 원하는 결과를 얻을 수 없게 됨       이문제를 피하기 위해서 contrast limit라는 값을 적용하여 이 값을 넘어가는 경우는 그 영역은 다른 영역에 균일하게 배분하여 적용           img = cv2.imread('/content/img.jpg', 0) print(img.shape)   (540, 960)   clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8)) img2 = clahe.apply(img)  plt.figure(figsize=(10,8))  plt.subplot(121) plt.imshow(img, 'gray') plt.title('Original')  plt.subplot(122) plt.imshow(img2, 'gray') plt.title('Equalization')  plt.show()      2D Histogram   cv2.calcHist()      지금까지 Histogram은 1차원으로 grayscale 이미지의 pixel의 강도, 즉 빛의 세기를 분석한 결과   2D Histogram은 Color 이미지의 색상(hue) &amp; 채도(saturation)을 동시에 분석하는 방법   색상과 채도를 분석하기 때문에 HSV Format으로 변환해야함                  파라미터       설명                       image       HSV로 변환된 이미지                 channel       0 -&gt; Hue, 1 -&gt; Saturation                 bins       [180,256] 첫 번째는 Hue, 두번째는 Saturation                 range       [0,180,0,256] Hue(0 ~ 180), Saturation(0 ~ 256)           !wget -O img.jpg https://cdn.pixabay.com/photo/2017/08/16/00/59/panorama-2646143_960_720.jpg   --2021-10-25 09:48:48--  https://cdn.pixabay.com/photo/2017/08/16/00/59/panorama-2646143_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 79946 (78K) [image/jpeg] Saving to: ‘img.jpg’  img.jpg             100%[===================&gt;]  78.07K  --.-KB/s    in 0.01s     2021-10-25 09:48:49 (6.03 MB/s) - ‘img.jpg’ saved [79946/79946]   img = cv2.imread('/content/img.jpg') print(img.shape)   (336, 960, 3)   hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) hist = cv2.calcHist([hsv], [0,1], None, [180,256], [0,180,0,256]) cv2_imshow(hist)      plt.imshow(hist) plt.show()         위 Histogram을 보면 X축은 Saturation, Y축은 Hue 값을 나타냄   Y축을 보면 100 근처에 값이 모여 있는 것을 알 수 있음   HSV 모델에서 H가 100이면 하늘색   이 이미지는 하늘색이 많이 분포되어 있다는 것을 2D Histogram을 통해서 알 수 있음   이미지 처리(Image Processing)      필요에 따라 적절한 처리   resize(), flip(), getAffineTransform(), warpAffine() 등 다양한 메서드 존재   Resize   cv2.resize()      사이즈가 변하면 pixel 사이의 값을 결정 해야함   보간법(Interpolation method)            사이즈를 줄일 때 : cv2.INTER_AREA       사이즈를 크게 할 때 : cv2.INTER_CUBIC, cv2.INTER_LINEAR                                      파라미터           설명                                           img           Image                             dsize           Manual Size, 가로, 세로 형태의 tuple(e.g., (100,200))                             fx           가로 사이즈의 배수, 2배로 크게 하려면 2, 반으로 줄이려면 0.5                             fy           세로 사이즈의 배수                             interpolation           보간법                           !wget -O moon.jpg https://cdn.pixabay.com/photo/2020/05/26/20/38/moon-5224745_960_720.jpg   --2021-10-25 09:48:49--  https://cdn.pixabay.com/photo/2020/05/26/20/38/moon-5224745_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 46659 (46K) [image/jpeg] Saving to: ‘moon.jpg’  moon.jpg            100%[===================&gt;]  45.57K  --.-KB/s    in 0.01s     2021-10-25 09:48:49 (4.35 MB/s) - ‘moon.jpg’ saved [46659/46659]   img = cv2.imread('/content/moon.jpg') print(img.shape)   (640, 960, 3)   cv2_imshow(img)      height, width = img.shape[:2]   shrink = cv2.resize(img, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_AREA) zoom1 = cv2.resize(img, (width*2, height*2), interpolation=cv2.INTER_CUBIC) zoom2 = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)   cv2_imshow(shrink) print(shrink.shape)      (320, 480, 3)   cv2_imshow(zoom1) print(zoom1.shape)      (1280, 1920, 3)   cv2_imshow(zoom2) print(zoom2.shape)      (1280, 1920, 3)   Translation   cv2.warpAffine()      이미지의 위치를 변경                  파라미터       설명                       src       Image                 M       변환 행렬                 dsize(tuple)       output image size(e.g., (width=columns, height-rows)           rows, cols = img.shape[:2]  M = np.float32([[1,0,20],[0,1,40]]) dst = cv2.warpAffine(img, M, (cols, rows))  cv2_imshow(dst)      Rotate   cv2.getRotationMatrix2D()      물체를 평면상의 한 점을 중심으로 θ 만큼 회전하는 변환   양의 각도는 시계 반대 방향으로 회전   음의 각도는 시계 방향으로 회전                  파라미터       설명                       center       이미지의 중심 좌표                 angle       회전 각도                 scale       scale factor           rows, cols = img.shape[:2]  M = cv2.getRotationMatrix2D((cols/2, rows/2), 60, 0.5) dst = cv2.warpAffine(img, M, (cols, rows))  cv2_imshow(dst) print(dst.shape)      (640, 960, 3)   Flip   cv2.flip()      대칭 변환            좌우 대칭(좌우 반전)       상하 대칭(상하 반전)           입력 영상과 출력 영상의 필셀이 1:1 매칭이므로 보간법이 필요 없음   img = cv2.imread('/content/moon.jpg') print(img.shape)   (640, 960, 3)   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  plt.imshow(img) plt.show()      rs1 = cv2.flip(img, 1)  plt.imshow(rs1) plt.show()      rs1 = cv2.flip(img, 0)  plt.imshow(rs1) plt.show()      rs1 = cv2.flip(img, -1)  plt.imshow(rs1) plt.show()      Affine Transformation   cv2.getAffineTransform()      선의 평행선은 유지되면서 이미지를 변환하는 작업   이동, 확대, scale, 반전까지 포함된 변환   Affine 변환을 위해서는 3개의 Match가 되는 점이 있으면 변환 행렬을 구할 수 있음   rows, cols, ch = img.shape  pts1 = np.float32([[200,100], [400,100], [200, 200]]) pts2 = np.float32([[200,300], [400,200], [200, 400]])  cv2.circle(img, (200,100), 10, (255,0,0), -1) cv2.circle(img, (400,100), 10, (0,255,0), -1) cv2.circle(img, (200,200), 10, (0,0,255), -1)  M = cv2.getAffineTransform(pts1, pts2)  dst = cv2.warpAffine(img, M, (cols, rows))  cv2_imshow(dst) print(dst.shape)      (640, 960, 3)   plt.subplot(121) plt.imshow(img[:,:,::-1]) plt.title('Image')  plt.subplot(122) plt.imshow(dst[:,:,::-1]) plt.title('Affine')   Text(0.5, 1.0, 'Affine')      Perspective Transformation      원근법(Perspective) 변환   직선의 성질만 유지, 선의 평행성은 유지가 되지 않는 변환   기차길은 서로 평행하지만 원근 변환을 거치면 평행성은 유지 되지 못하고 하나의 점에서 만나는 것처럼 보임(반대의 변환도 가능)   4개의 Point의 Input 값과 이동할 output point가 필요   cv2.getPerspectiveTransform()가 필요하며, cv2.warpPerspective() 함수에 변환 행렬값을 적용하여 최종 결과 이미지를 얻을 수 있음   !wget -O train.jpg https://cdn.pixabay.com/photo/2015/04/04/06/54/train-706219_960_720.jpg   --2021-10-25 09:48:54--  https://cdn.pixabay.com/photo/2015/04/04/06/54/train-706219_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 104848 (102K) [image/jpeg] Saving to: ‘train.jpg’  train.jpg           100%[===================&gt;] 102.39K  --.-KB/s    in 0.02s     2021-10-25 09:48:54 (4.80 MB/s) - ‘train.jpg’ saved [104848/104848]   img = cv2.imread('/content/train.jpg') print(img.shape)   (720, 481, 3)   cv2_imshow(img)         좌표점은 (왼쪽 위) -&gt; (오른쪽 위) -&gt; (오른쪽 아래) -&gt; (왼쪽 아래)   top_left = (180, 300) top_right = (270, 300) bottom_left = (80, 550) bottom_right = (400, 550)  pts1 = np.float32([top_left, top_right, bottom_right, bottom_left])  w1 = abs(bottom_right[0] - bottom_left[0]) w2 = abs(top_right[0] - top_left[0]) h1 = abs(top_right[1] - bottom_right[1]) h2 = abs(top_left[1] - bottom_left[1])  max_width = max([w1, w2]) max_height = max([h1, h2])  pts2 = np.float32([[0,0], [max_width-1,0], [max_width-1,max_height-1], [0, max_height-1]])   cv2.circle(img, top_left, 10, (255,0,0), -1) cv2.circle(img, top_right, 10, (0,255,0), -1) cv2.circle(img, bottom_left, 10, (0,0,255), -1) cv2.circle(img, bottom_right, 10, (255,255,255), -1)  cv2_imshow(img)      M = cv2.getPerspectiveTransform(pts1, pts2)  dst = cv2.warpPerspective(img, M, (max_width, max_height))  plt.subplot(121) plt.imshow(img[:,:,::-1]) plt.title('Image')  plt.subplot(122) plt.imshow(dst[:,:,::-1]) plt.title('Perspective')  plt. show()      이미지 연산(Image Operation)      이미지는 배열(array)로 표현 가능하여 여러가지 연산 가능   !wget -O tree.jpg https://cdn.pixabay.com/photo/2014/03/05/21/12/desert-279862_960_720.jpg   --2021-10-25 09:48:55--  https://cdn.pixabay.com/photo/2014/03/05/21/12/desert-279862_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 164397 (161K) [image/jpeg] Saving to: ‘tree.jpg’  tree.jpg            100%[===================&gt;] 160.54K  --.-KB/s    in 0.03s     2021-10-25 09:48:55 (6.15 MB/s) - ‘tree.jpg’ saved [164397/164397]   tree = cv2.imread('/content/tree.jpg') print(tree.shape)   (654, 960, 3)   cv2_imshow(tree)      temp_px = tree[200,200] print(temp_px)   [50 49 39]   temp_ch = tree[200,200,2] print(temp_ch)   39   값 변경   tree[100:120,100] = [0,0,255]   cv2_imshow(tree)      인덱싱   print(tree[:100,:100].shape)   (100, 100, 3)   cv2_imshow(tree[400:500,400:500])      white_box = tree[400:500,400:500] white_box = [255,255,255] tree[400:500,400:500] = white_box   cv2_imshow(tree)      이미지 ROI      이미지 작업시에는 특정 pixel 단위 보다는 특정 영역단위로 작업을 하게 되는데 이것을 Region of Image(ROI)라고 함   ROI 설정은 Numpy의 indexing을 사용, 특정 영역을 copy 할 수도 있음   tree = cv2.imread('/content/tree.jpg') print(tree.shape)   (654, 960, 3)   cv2_imshow(tree)      t = tree[:500,760:] cv2_imshow(t)      tree[:500,100:300] = t cv2_imshow(tree)      tree[100:600,400:600] = t cv2_imshow(tree)      이미지의 Channels      B, G, R로 구성된 채널을 분리, 합칠 수 있음            cv2.split()       cv2.merge()           b, g, r = cv2.split(tree)   print(b) print(b.shape)   [[ 32  32  33 ...  55  55  55]  [ 32  32  32 ...  55  55  55]  [ 32  32  32 ...  54  54  54]  ...  [ 42  47  31 ... 127 132 109]  [ 26   9   1 ...  96 117 140]  [ 16  65 107 ... 131 116 110]] (654, 960)   print(g) print(g.shape)   [[ 30  30  31 ...  55  55  55]  [ 30  30  30 ...  55  55  55]  [ 30  30  30 ...  54  54  54]  ...  [ 43  49  34 ... 150 155 132]  [ 30  13   7 ... 123 144 167]  [ 22  71 116 ... 158 144 138]] (654, 960)   print(r) print(r.shape)   [[ 20  20  21 ...  43  43  43]  [ 20  20  20 ...  43  43  43]  [ 20  20  20 ...  42  42  42]  ...  [ 53  57  42 ... 176 181 158]  [ 41  24  18 ... 144 164 187]  [ 35  84 126 ... 178 161 155]] (654, 960)   img = cv2.merge((b,g,r)) print(img.shape)   (654, 960, 3)   cv2_imshow(img)         cv2.split() 함수는 비용이 많이 드는 함수이므로, 가능하다면 Numpy indexing을 사용하는게 효율적   R 채널 0으로 값 변경   img[:,:,2] = 0 print(img)   [[[ 32  30   0]   [ 32  30   0]   [ 33  31   0]   ...   [ 55  55   0]   [ 55  55   0]   [ 55  55   0]]   [[ 32  30   0]   [ 32  30   0]   [ 32  30   0]   ...   [ 55  55   0]   [ 55  55   0]   [ 55  55   0]]   [[ 32  30   0]   [ 32  30   0]   [ 32  30   0]   ...   [ 54  54   0]   [ 54  54   0]   [ 54  54   0]]   ...   [[ 42  43   0]   [ 47  49   0]   [ 31  34   0]   ...   [127 150   0]   [132 155   0]   [109 132   0]]   [[ 26  30   0]   [  9  13   0]   [  1   7   0]   ...   [ 96 123   0]   [117 144   0]   [140 167   0]]   [[ 16  22   0]   [ 65  71   0]   [107 116   0]   ...   [131 158   0]   [116 144   0]   [110 138   0]]]   cv2_imshow(img)         G 채널 0으로 값 변경   img[:,:,1] = 0 print(img)   [[[ 32   0   0]   [ 32   0   0]   [ 33   0   0]   ...   [ 55   0   0]   [ 55   0   0]   [ 55   0   0]]   [[ 32   0   0]   [ 32   0   0]   [ 32   0   0]   ...   [ 55   0   0]   [ 55   0   0]   [ 55   0   0]]   [[ 32   0   0]   [ 32   0   0]   [ 32   0   0]   ...   [ 54   0   0]   [ 54   0   0]   [ 54   0   0]]   ...   [[ 42   0   0]   [ 47   0   0]   [ 31   0   0]   ...   [127   0   0]   [132   0   0]   [109   0   0]]   [[ 26   0   0]   [  9   0   0]   [  1   0   0]   ...   [ 96   0   0]   [117   0   0]   [140   0   0]]   [[ 16   0   0]   [ 65   0   0]   [107   0   0]   ...   [131   0   0]   [116   0   0]   [110   0   0]]]   cv2_imshow(img)         B 채널 0으로 값 변경   img[:,:,0] = 0 print(img)   [[[0 0 0]   [0 0 0]   [0 0 0]   ...   [0 0 0]   [0 0 0]   [0 0 0]]   [[0 0 0]   [0 0 0]   [0 0 0]   ...   [0 0 0]   [0 0 0]   [0 0 0]]   [[0 0 0]   [0 0 0]   [0 0 0]   ...   [0 0 0]   [0 0 0]   [0 0 0]]   ...   [[0 0 0]   [0 0 0]   [0 0 0]   ...   [0 0 0]   [0 0 0]   [0 0 0]]   [[0 0 0]   [0 0 0]   [0 0 0]   ...   [0 0 0]   [0 0 0]   [0 0 0]]   [[0 0 0]   [0 0 0]   [0 0 0]   ...   [0 0 0]   [0 0 0]   [0 0 0]]]   cv2_imshow(img)      이미지 더하기      cv2.add()   cv2.addWeighted()   Numpy 더하기 연산   cv2.add() : Saturation 연산            Saturation 연산은 한계값을 정하고 그 값을 벗어나는 경우는 모두 특정 값으로 계산하는 방식       이미지에서는 0 이하는 모두 0, 255 이상은 모두 255로 표현           Numpy : modulo 연산            a와 b는 n으로 나눈 나머지 값이 같다라는 의미       이미지에서는 연산의 결과가 256 보다 큰 경우는 256으로 나눈 나머지 값으로 결정           x = np.uint8([250]) y = np.uint8([10])      cv2.add() 연산   cv2.add(x,y)   array([[255]], dtype=uint8)      Numpy 연산   print(x+y)   [4]   !wget -O dog1.jpg https://cdn.pixabay.com/photo/2021/01/26/17/18/cavalier-king-charles-spaniel-5952324_960_720.jpg !wget -O dog2.jpg https://cdn.pixabay.com/photo/2017/09/25/13/14/dog-2785077_960_720.jpg  dog1 = cv2.imread('/content/dog1.jpg') dog2 = cv2.imread('/content/dog2.jpg')  print(dog1.shape) print(dog2.shape)   --2021-10-25 09:48:59--  https://cdn.pixabay.com/photo/2021/01/26/17/18/cavalier-king-charles-spaniel-5952324_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 96413 (94K) [image/jpeg] Saving to: ‘dog1.jpg’  dog1.jpg            100%[===================&gt;]  94.15K  --.-KB/s    in 0.01s     2021-10-25 09:48:59 (6.39 MB/s) - ‘dog1.jpg’ saved [96413/96413]  --2021-10-25 09:48:59--  https://cdn.pixabay.com/photo/2017/09/25/13/14/dog-2785077_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 110491 (108K) [image/jpeg] Saving to: ‘dog2.jpg’  dog2.jpg            100%[===================&gt;] 107.90K  --.-KB/s    in 0.02s     2021-10-25 09:48:59 (4.85 MB/s) - ‘dog2.jpg’ saved [110491/110491]  (640, 960, 3) (640, 960, 3)      cv2.add() 연산   rs1 = cv2.add(dog1,dog2) cv2_imshow(rs1)         Numpy 연산   rs2 = dog1 + dog2 cv2_imshow(rs2)      비트 연산      AND, OR, NOT, XOR 연산            bitwise_and : 둘 다 0이 아닌 경우만 값을 통과       bitwise_or : 둘 중 하나가 0이 아니면 값을 통과       bitwise_not : 해당 값에 대해 부정값을 통과       bitwise_xor : 두 요소의 논리적 배타값 통과           !wget -O star.png https://www.pinclipart.com/picdir/middle/124-1240560_star-vector-art-9-buy-clip-art-compass.png   --2021-10-25 09:48:59--  https://www.pinclipart.com/picdir/middle/124-1240560_star-vector-art-9-buy-clip-art-compass.png Resolving www.pinclipart.com (www.pinclipart.com)... 173.208.239.244 Connecting to www.pinclipart.com (www.pinclipart.com)|173.208.239.244|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 142551 (139K) [image/png] Saving to: ‘star.png’  star.png            100%[===================&gt;] 139.21K  --.-KB/s    in 0.08s     2021-10-25 09:49:00 (1.78 MB/s) - ‘star.png’ saved [142551/142551]   star = cv2.imread('/content/star.png') print(star.shape)   (800, 880, 3)   plt.imshow(star) plt.show()      bk_img = np.zeros((800,880,3))   plt.imshow(bk_img) plt.show()      bk_img[:,:440,:] = (255,255,255)      이미지의 dtype을 int형으로 변환   img = bk_img.astype(np.uint8) plt.imshow(img) plt.show()      bitwise_and 연산   rs = cv2.bitwise_and(img, star) plt.imshow(rs) plt.show()      bitwise_or 연산   rs = cv2.bitwise_or(img, star) plt.imshow(rs) plt.show()      bitwise_not 연산   rs = cv2.bitwise_not(img) plt.imshow(rs) plt.show()      rs = cv2.bitwise_not(star) plt.imshow(rs) plt.show()      bitwise_xor 연산   rs = cv2.bitwise_xor(img, star) plt.imshow(rs) plt.show()      tmp_star = cv2.bitwise_not(star) rs = cv2.bitwise_xor(img, tmp_star) plt.imshow(rs) plt.show()      비트 연산 예시      이미지에 OpenCV 로고 넣기   !wget -O bk.jpg https://cdn.pixabay.com/photo/2011/12/14/12/17/galaxy-11098_960_720.jpg !wget -O logo.png https://media.vlpt.us/images/seonghun-dev/post/72db176a-a9e5-492f-a484-7024388098cc/opencv_logo_icon_170888.png   --2021-10-25 09:49:03--  https://cdn.pixabay.com/photo/2011/12/14/12/17/galaxy-11098_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 61119 (60K) [image/jpeg] Saving to: ‘bk.jpg’  bk.jpg              100%[===================&gt;]  59.69K  --.-KB/s    in 0.01s     2021-10-25 09:49:03 (5.44 MB/s) - ‘bk.jpg’ saved [61119/61119]  --2021-10-25 09:49:03--  https://media.vlpt.us/images/seonghun-dev/post/72db176a-a9e5-492f-a484-7024388098cc/opencv_logo_icon_170888.png Resolving media.vlpt.us (media.vlpt.us)... 172.67.157.210, 104.21.8.194, 2606:4700:3030::6815:8c2, ... Connecting to media.vlpt.us (media.vlpt.us)|172.67.157.210|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 15467 (15K) [image/png] Saving to: ‘logo.png’  logo.png            100%[===================&gt;]  15.10K  --.-KB/s    in 0s        2021-10-25 09:49:03 (61.2 MB/s) - ‘logo.png’ saved [15467/15467]   bk = cv2.imread('/content/bk.jpg') logo = cv2.imread('/content/logo.png') print(bk.shape) print(logo.shape)   (600, 960, 3) (407, 749, 3)      삽입할 이미지의 row, cols, channel 정보   대상 이미지에서 삽입할 이미지의 영역을 추출   rows, cols, ch = logo.shape bk_img = bk[0:rows,0:cols] bk_img.shape   (407, 749, 3)   rows, cols, ch = bk_img.shape opencv = logo[0:rows,0:cols] opencv.shape   (407, 749, 3)      mask를 만들기 위해서 logo 이미지를 gray scale로 변경 후 binary image로 전환   mask 는 logo 부분이 흰색(255), 바탕은 검은색(0)   mask_inv는 log 부분이 검은색(0), 바탕은 흰색(255)   opencv_gray = cv2.cvtColor(opencv, cv2.COLOR_BGR2GRAY) plt.imshow(opencv_gray, cmap='gray') plt.show()      ret, mask = cv2.threshold(opencv_gray,200,255,cv2.THRESH_BINARY_INV) mask_inv = cv2.bitwise_not(mask)   plt.imshow(mask, cmap='gray') plt.show()      plt.imshow(mask_inv, cmap='gray') plt.show()      img1_fg = cv2.bitwise_and(opencv, opencv, mask=mask) img2_bg = cv2.bitwise_and(bk_img, bk_img, mask=mask_inv)   dst = cv2.add(img1_fg,img2_bg) cv2_imshow(dst)      bk_img[:rows,:cols] = dst cv2_imshow(bk_img)      이미지 블렌딩(Image Blending)   cv2.addWeighted()      두 이미지를 blending 할 수 있음   blending 하려는 두 이미지의 사이즈가 같아야함   [Simple Formula] \\(g(x) = (1-α)f_0(x_I) + αf_1(x)\\)            β = 1 - α       α, β의 값을 통해 어떤 이미지를 더 강하게 드러내고, 어떤 이미지를 더 약하게 드러낼지 결정       γ 추가 가능 (optional)           !wget -O dnc.jpg https://thumbs.dreamstime.com/b/red-do-not-copy-stencil-type-word-watermark-frame-103747612.jpg !wget -O bk.jpg https://cdn.pixabay.com/photo/2016/11/19/10/29/background-1838494_960_720.jpg   --2021-10-25 09:49:04--  https://thumbs.dreamstime.com/b/red-do-not-copy-stencil-type-word-watermark-frame-103747612.jpg Resolving thumbs.dreamstime.com (thumbs.dreamstime.com)... 192.229.163.122 Connecting to thumbs.dreamstime.com (thumbs.dreamstime.com)|192.229.163.122|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 35192 (34K) [image/jpeg] Saving to: ‘dnc.jpg’  dnc.jpg             100%[===================&gt;]  34.37K  --.-KB/s    in 0s        2021-10-25 09:49:04 (108 MB/s) - ‘dnc.jpg’ saved [35192/35192]  --2021-10-25 09:49:04--  https://cdn.pixabay.com/photo/2016/11/19/10/29/background-1838494_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 262746 (257K) [image/jpeg] Saving to: ‘bk.jpg’  bk.jpg              100%[===================&gt;] 256.59K  --.-KB/s    in 0.03s     2021-10-25 09:49:04 (7.63 MB/s) - ‘bk.jpg’ saved [262746/262746]   img1 = cv2.imread('/content/bk.jpg') img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB) img2 = cv2.imread('/content/dnc.jpg') img2 = cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)  print(img1.shape) print(img2.shape)   (640, 960, 3) (571, 800, 3)   plt.imshow(img1) plt.show()      plt.imshow(img2) plt.show()      img1 = cv2.resize(img1, (500,500)) img2 = cv2.resize(img2, (500,500)) print(img1.shape) print(img2.shape)   (500, 500, 3) (500, 500, 3)   plt.imshow(img1) plt.show()      plt.imshow(img2) plt.show()      blended = cv2.addWeighted(src1=img1, alpha=0.5, src2=img2, beta=0.5, gamma=0) plt.imshow(blended) plt.show()      blended = cv2.addWeighted(src1=img1, alpha=0.8, src2=img2, beta=0.1, gamma=0) plt.imshow(blended) plt.show()      이미지 이진화(Image Theshoding)   기본 임계 처리   cv2.threshold()      이진화 : 영상을 흑/백으로 분류하여 처리하는 것            기준이 되는 임계값을 어떻게 결정할 것인지가 중요한 문제       임계값보다 크면 백, 작으면 흑이 되는데, 기본 임계처리는 사용자가 고정된 임계값을 결정하고 그 결과를 보여주는 단순한 형태       기본적으로 이미지의 segmenting의 가장 간단한 방법                                      파라미터           설명                                           src           Input Image로 single-channel 이미지.(grayscale 이미지)                             thresh           임계값                             maxval           임계값을 넘었을 때 적용함 value                             type           thresholding type                                  thresholding type                    cv2.THRESH_BINARY                            src(x,y) &gt; thresh 일 때, maxval               그 외, 0                                   cv2.THRESH_BINARY_INV                            src(x,y) &gt; thresh 일 때, 0               그 외, maxval                                   cv2.THRESH_TRUNC                            src(x,y) &gt; thresh 일 때, thresh               그 외, src(x,y)                                   cv2.THRESH_TOZERO                            src(x,y) &gt; thresh 일 때, src(x,y)               그 외, 0                                   cv2.THRESH_TOZERO_INV                            src(x,y) &gt; thresh 일 때, 0               그 외, src(x,y)                                                   !wget -O letters.jpg https://cdn.pixabay.com/photo/2020/12/09/17/18/letters-5818033_960_720.jpg   --2021-10-25 09:49:06--  https://cdn.pixabay.com/photo/2020/12/09/17/18/letters-5818033_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 241463 (236K) [image/jpeg] Saving to: ‘letters.jpg’  letters.jpg         100%[===================&gt;] 235.80K  --.-KB/s    in 0.03s     2021-10-25 09:49:06 (7.65 MB/s) - ‘letters.jpg’ saved [241463/241463]   img = cv2.imread('/content/letters.jpg', 0) img.shape   (640, 960)   plt.imshow(img, cmap='gray') plt.show()      ret, thresh1 = cv2.threshold(img, 128, 255, cv2.THRESH_BINARY) ret, thresh2 = cv2.threshold(img, 128, 255, cv2.THRESH_BINARY_INV) ret, thresh3 = cv2.threshold(img, 128, 255, cv2.THRESH_TRUNC) ret, thresh4 = cv2.threshold(img, 128, 255, cv2.THRESH_TOZERO) ret, thresh5 = cv2.threshold(img, 128, 255, cv2.THRESH_TOZERO_INV)   titles = ['Original', 'Binary', 'Binary_Inv', 'Trunc', 'Tozero', 'Tozero_Inv'] images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]   plt.figure(figsize=(14,8)) for i in range(6):   plt.subplot(2,3,i+1)   plt.imshow(images[i], 'gray')   plt.title(titles[i])   plt.xticks([])   plt.yticks([])  plt.show()      !wget -O snow.jpg https://cdn.pixabay.com/photo/2016/03/09/09/21/snowflake-1245748_960_720.jpg   --2021-10-25 09:49:07--  https://cdn.pixabay.com/photo/2016/03/09/09/21/snowflake-1245748_960_720.jpg Resolving cdn.pixabay.com (cdn.pixabay.com)... 104.18.20.183, 104.18.21.183, 2606:4700::6812:15b7, ... Connecting to cdn.pixabay.com (cdn.pixabay.com)|104.18.20.183|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 90437 (88K) [image/jpeg] Saving to: ‘snow.jpg’  snow.jpg            100%[===================&gt;]  88.32K  --.-KB/s    in 0.01s     2021-10-25 09:49:08 (5.85 MB/s) - ‘snow.jpg’ saved [90437/90437]   img = cv2.imread('/content/snow.jpg', 0) img.shape   (720, 960)   plt.imshow(img, cmap='gray') plt.show()      ret, thresh1 = cv2.threshold(img, 128, 255, cv2.THRESH_BINARY) ret, thresh2 = cv2.threshold(img, 128, 255, cv2.THRESH_BINARY_INV) ret, thresh3 = cv2.threshold(img, 128, 255, cv2.THRESH_TRUNC) ret, thresh4 = cv2.threshold(img, 128, 255, cv2.THRESH_TOZERO) ret, thresh5 = cv2.threshold(img, 128, 255, cv2.THRESH_TOZERO_INV)   titles = ['Original', 'Binary', 'Binary_Inv', 'Trunc', 'Tozero', 'Tozero_Inv'] images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]   plt.figure(figsize=(14,8)) for i in range(6):   plt.subplot(2,3,i+1)   plt.imshow(images[i], 'gray')   plt.title(titles[i])   plt.xticks([])   plt.yticks([])  plt.show()      적응 임계처리   cv2.adaptiveThreshold()      이전 단계에서는 임계값을 이미지 전체에 적용하여 처리하기 때문에 하나의 이미지에 음영이 다르면 일부 영역이 모두 흰색 또는 검정색으로 보여지게 됨   이런 문제를 해결하기 위해서 이미지의 작은 영역별로 thresholding                  파라미터       설명                       src       grayscale image                 maxValue       임계값                 adaptiveMethod       thresholding value를 결정하는 계산 방법                 thresholdType       threshold type                 blockSize       thresholding을 적용할 영역 사이즈                 C       평균이나 가중평균에서 차감할 값              Adaptive Method            cv2.ADAPTIVE_THRESH_MEAN_C : 주변 영역의 평균값으로 결정       cv2.ADAPTIVE_THRESH_GAUSSIAN_C : 주변 영역의 가우시안 값으로 결정           img = cv2.imread('/content/letters.jpg', 0) img.shape   (640, 960)   ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY) th2 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, 2) th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 15, 2)   titles = ['Original', 'Global', 'Mean', 'Gaussian'] images = [img, th1, th2, th3]   plt.figure(figsize=(14,10)) for i in range(4):   plt.subplot(2,2,i+1)   plt.imshow(images[i], 'gray')   plt.title(titles[i])   plt.xticks([])   plt.yticks([])  plt.show()      Otsu의 이진화      Otsu의 이진화(Otsu’s Binarization)란 bimodal image에서 임계값을 자동으로 계산하는 것   임계값을 결정하는 가장 일반적인 방법은 trial and error 방식   bimodal image(히스토그램으로 분석하면 2개의 peak가 있는 이미지)의 경우는 히스토그램에서 임계값을 어느 정도 정확히 계산 가능   cv2.threshold() 함수의 flag에 추가로 cv2.THRESH_OTSU를 적용. 이때 임계값은 0으로 전달   !wget -O noise.jpg https://i.stack.imgur.com/J13Wn.jpg   --2021-10-25 09:49:10--  https://i.stack.imgur.com/J13Wn.jpg Resolving i.stack.imgur.com (i.stack.imgur.com)... 199.232.64.193 Connecting to i.stack.imgur.com (i.stack.imgur.com)|199.232.64.193|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 444265 (434K) [image/jpeg] Saving to: ‘noise.jpg’  noise.jpg           100%[===================&gt;] 433.85K  --.-KB/s    in 0.04s     2021-10-25 09:49:10 (10.5 MB/s) - ‘noise.jpg’ saved [444265/444265]   noise = cv2.imread('/content/noise.jpg', 0) noise.shape   (720, 960)   ret1, th1 = cv2.threshold(noise, 127, 255, cv2.THRESH_BINARY) ret2, th2 = cv2.threshold(noise, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) blur = cv2.GaussianBlur(noise, (5,5), 0) ret3, th3 = cv2.threshold(noise, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)   titles = ['Original', 'Histogram', 'Global Thresholding (t=127)',           'Original', 'Histogram', 'Otsu Thresholding',           'Gaussian', 'Histogram', 'Otsu Thresholding'] images = [noise, 0, th1, noise, 0, th2, blur, 0, th3]   plt.figure(figsize=(14,10)) for i in range(3):   plt.subplot(3,3,i*3+1)   plt.imshow(images[i*3], 'gray')   plt.title(titles[i*3])   plt.xticks([])   plt.yticks([])    plt.subplot(3,3,i*3+2)   plt.hist(images[i*3].ravel(), 256)   plt.title(titles[i*3+1])   plt.xticks([])   plt.yticks([])    plt.subplot(3,3,i*3+3)   plt.imshow(images[i*3+2], 'gray')   plt.title(titles[i*3+2])   plt.xticks([])   plt.yticks([])   plt.show()      이미지 필터링(Image Filtering)   cv2.filter2D()      이미지도 음성 신호처럼 주파수로 표현할 수 있음   일반적으로 고주파는 밝기의 변화가 많은 곳, 즉 경계선 영역에서 나타나며, 일반적인 배경은 저주파로 나타냄            이것을 바탕으로 고주파를 제거하면 Blur 처리가 되며, 저주파를 제거하면 대상의 영역을 확인 가능           Low-pass filter(LPF)와 High-pass filter(HPF)를 이용하여, LPF를 적용하면 노이즈제거나 blur 처리를 할 수 있으며, HPF를 적용하면 경계선을 찾을 수 있음   일반적으로 많이 사용되는 필터   ex) \\(K = \\frac{1}{25}\\begin{vmatrix}1&amp;1&amp;1&amp;1&amp;1\\\\1&amp;1&amp;1&amp;1&amp;1\\\\1&amp;1&amp;1&amp;1&amp;1\\\\1&amp;1&amp;1&amp;1&amp;1\\\\1&amp;1&amp;1&amp;1&amp;1\\\\ \\end{vmatrix}\\)   !wget -O bee.jpg https://ideas.ted.com/wp-content/uploads/sites/3/2021/03/FINAL_Bees.jpg?resize=750,450   --2021-10-25 09:49:12--  https://ideas.ted.com/wp-content/uploads/sites/3/2021/03/FINAL_Bees.jpg?resize=750,450 Resolving ideas.ted.com (ideas.ted.com)... 192.0.66.192, 2a04:fa87:fffd::c000:42c0 Connecting to ideas.ted.com (ideas.ted.com)|192.0.66.192|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 260164 (254K) [image/jpeg] Saving to: ‘bee.jpg’  bee.jpg             100%[===================&gt;] 254.07K  --.-KB/s    in 0.04s     2021-10-25 09:49:13 (5.59 MB/s) - ‘bee.jpg’ saved [260164/260164]   img = cv2.imread('/content/bee.jpg') img.shape   (450, 750, 3)   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) plt.imshow(img) plt.show()      kernel = np.ones((5,5), np.float32) / 25 print(kernel.shape) print(kernel)   (5, 5) [[0.04 0.04 0.04 0.04 0.04]  [0.04 0.04 0.04 0.04 0.04]  [0.04 0.04 0.04 0.04 0.04]  [0.04 0.04 0.04 0.04 0.04]  [0.04 0.04 0.04 0.04 0.04]]   dst = cv2.filter2D(img, -1, kernel) plt.imshow(dst) plt.show()      이미지 샤프닝(Image Sharpening)      출력화소에서 이웃 화소끼리 차이를 크게 해서 날카로운 느낌이 나게 만드는 것   영상의 세세한 부분을 강조할 수 있으며, 경계 부분에서 명암대비가 증가되는 효과   사프닝 커널            커널 원소들의 값 차이가 커지도록 구성       커널 원소 전체 합이 1이 되어야 입력영상 밝기가 손실 없이 출력 영상 밝기로 유지           img = cv2.imread('/content/bee.jpg') img.shape   (450, 750, 3)   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) plt.imshow(img) plt.show()      kernel = [0, -1, 0,           -1, 5, -1,           0, -1, 0] mask = np.array(kernel, np.float32).reshape(3,3) sharpen = cv2.filter2D(img, -1, mask)   plt.imshow(sharpen) plt.show()      kernel = [-1, -1, -1,           -1, 9, -1,           -1, -1, -1] mask = np.array(kernel, np.float32).reshape(3,3) sharpen = cv2.filter2D(img, -1, mask)   plt.imshow(sharpen) plt.show()      이미지 블러링(Image Blurring)      low-pass filter를 이미지에 적용하여 얻을 수 있음   고주파영역을 제거함으로써 노이즈를 제거하거나 경계선을 흐리게 할 수 있음   OpenCV에서 저공하는 blurring 방법            Averaging       Gaussian Filtering       Median Filtering       Bilateral Filtering           Averaging      Box형태의 kernel을 이미지에 적용한 후 평균값을 box의 중심점에 적용하는 형태   cv2.blur() 또는 cv2.boxFilter()   cv2.blur()            Parameters                    src : Chennel 수는 상관없으나, depth(Data Type)은 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F           ksize : kernel 사이즈(ex; (3,3))                       ex) \\(K = \\frac{1}{9}\\begin{vmatrix}1&amp;1&amp;1\\\\1&amp;1&amp;1\\\\1&amp;1&amp;1\\\\ \\end{vmatrix}\\)       이미지의 Data Type                                      데이터 타입           설명                                           CV_8U           8-bit unsigned integer: uchar (0..255)                             CV_8S           8-bit signed integer: schar (-128..127)                             CV_16U           16-bit unsigned integer: ushort (0..65535)                             CV_16S           16-bit signed integer: short (-32768..32767)                             CV_32S           32-bit signed integer: int (-2147483648..2147483647)                             CV_32F           32-bit floating-point number: float (-FLT_MAX..FLT_MAX, INF, NAN)                             CV_64F           64-bit floating-point number: double (-DBL_MAX..DBL_MAX, INF, NAN)                                  일반적으로 Data Type과 채널수가 같이 표현이 되어 CV_8UC1과 같이 표현(8bit unsigned integer이면서 채널이 1개)           img = cv2.imread('/content/bee.jpg') img.shape   (450, 750, 3)   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)   plt.title('Original') plt.imshow(img) plt.show()      dst1 = cv2.blur(img, (7,7))   plt.title('Averaging Blurring') plt.imshow(dst1) plt.show()      Gaussian Filtering   cv2.GaussianBlur()      box filter는 동일한 값으로 구성된 kernel을 사용하지만, Gaussian Filter는 Gaussian 함수를 이용한 kernel을 적용            kernel 행렬의 값을 Gaussian 함수를 통해서 수학적으로 생성하여 적용           kernel의 사이즈는 야수이면서 홀수로 지정을 해야 됨   이미지의 Gaussian Noise(전체적으로 밀도가 동일한 노이즈, 백색 노이즈)를 제거하는데 가장 효과적                  파라미터       설명                       img       Chennel수는 상관없으나, depth(Data Type)은 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F                 ksize       (width, height) 형태의 kernel size, width와 height는 서로 다를 수 있지만, 양수의 홀수로 지정해야함                 sigmaX       Gaussian kernel standard deviation in X direction           plt.title('Original') plt.imshow(img) plt.show()      dst2 = cv2.GaussianBlur(img, (5,5), 0)   plt.title('GaussianBlur') plt.imshow(dst2) plt.show()      Median Filtering   cv2.medianBlur()      kernel window와 pixel의 값들을 정렬한 후에 중간값을 선택하여 적용   salt-and-pepper noise 제거에 가장 효과적                  파라미터       설명                       src       1,3,4 channel image, depth가 CV_8U, CV_16U, or CV_32_F 이면 ksize는 3 또는 5, CV_8U이면 더 큰 ksize 가능                 ksize       1보다 큰 홀수           plt.title('Original') plt.imshow(img) plt.show()      dst3 = cv2.medianBlur(img, 9)   plt.title('Median Blur') plt.imshow(dst3) plt.show()      Bilateral Filtering   cv2.bilateralFilter()      위 3가지 Blur 방식은 경계선까지 blur 처리가 되어, 경계선이 흐려짐   Bilateral Filtering(양방향 필터)은 경계선을 유지하면서 Gaussian Blur 처리를 해주는 방법                  파라미터       설명                       src       8-bit, 1 or 3 Channel image                 d       filtering 시 고려할 주변 pixel 지름                 sigmaColor       Color를 고려할 공간. 숫자가 크면 멀리 있는 색도 고려                 sigmaSpace       숫자가 크면 멀리 있는 pixel도 고려           plt.title('Original') plt.imshow(img) plt.show()      dst4 = cv2.bilateralFilter(img, 9, 75, 75)   plt.title('Bilateral Filter') plt.imshow(dst4) plt.show()      titles = ['Original', 'Blur(7x7)', 'Gaussian Blur(5x5)', 'Median Blur', 'Bilateral'] images = [img, dst1, dst2, dst3, dst4]  plt.figure(figsize=(14,16)) for i in range(5):   plt.subplot(3,2,i+1)   plt.imshow(images[i])   plt.title(titles[i])   plt.xticks([])   plt.yticks([])  plt.show()      형태학적 변환(Morphological Transformations)      이미지를 Segmentation하여 단순화, 제거, 보정을 통해서 형태를 파악하는 목적으로 사용   일반적으로 binary나 grayscale image에 사용   사용하는 방법으로는 Dilation(팽창), Erosion(침식), 그리고 2개를 조합한 Opening과 Closing이 있음   여기에는 2가지 Input 값이 있는데, 하나는 원본 이미지이고 또 다른 하나는 structuring element   structuring element            원본 이미지에 적용되는 kernel       중심을 원점으로 사용할 수도 있고, 원점을 변경할 수도 있음       일반적으로 꽉찬 사각형, 타원형, 십자가형을 많이 사용           !wget -O two.jpg https://hollandbikeshop.com/img/prod/gmg-yepp-abc-susja-2-8715362005809-0-l.jpg   --2021-10-25 09:49:18--  https://hollandbikeshop.com/img/prod/gmg-yepp-abc-susja-2-8715362005809-0-l.jpg Resolving hollandbikeshop.com (hollandbikeshop.com)... 213.206.238.157, 2001:4018:8800:100:213:206:238:157 Connecting to hollandbikeshop.com (hollandbikeshop.com)|213.206.238.157|:443... connected. HTTP request sent, awaiting response... 200 OK Length: unspecified [image/jpeg] Saving to: ‘two.jpg’  two.jpg                 [ &lt;=&gt;                ]  19.02K  --.-KB/s    in 0.09s     2021-10-25 09:49:19 (203 KB/s) - ‘two.jpg’ saved [19478]   img = cv2.imread('/content/two.jpg') cv2_imshow(img)      Erosion   cv2.erode()      각 Pixel에 structuring element를 적용하여 하나라도 0이 있으면 대상 pixel을 제거하는 방법   작은 object를 제거하는 효과                  파라미터       설명                       src       the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F of CV_64F                 kernel       structuring element. cv2.getStructuringElemet() 함수로 만들 수 있음                 anchor       structuring element의 중심. default(-1,-1)로 중심점                 iterations       erosion 적용 반복 횟수              아래 그림은 대상 이미지에 십자형 structuring element를 적용한 결과      kernel = np.ones((5,5), np.uint8) erosion = cv2.erode(img, kernel, iterations=1) cv2_imshow(erosion)      Dilation   cv2.dilate()      Erosion과 반대 작용   대상을 확장한 후 작은 구멍을 채우는 방법   Erosion과 마찬가지로 각 pixel에 structuring element를 적용   대상 pixel에 대해서 OR 연산을 수행   즉, 겹치는 부분이 하나라도 있으면 이미지를 확장      kernel = np.ones((5,5), np.uint8) dilation = cv2.dilate(img, kernel, iterations=1) cv2_imshow(dilation)      Opening &amp; Closing   cv2.morphologyEx()      Opening과 Closing은 Erosion 과 Dilation의 조합 결과   차이는 어느 것을 먼저 적용을 하는 차이   Opening : Erosion 적용 후 Dilation 적용. 작은 Object이나 돌기 제거에 적합   Closing : Dilation 적용 후 Erosion 적용. 전체적인 윤곽 파악에 적합                     파라미터       설명                       src       원본 이미지. 채널수는 상관 없으나, depth는 다음 중 하나여야함(CV_8U, CV_16U, CV_16S, CV_32F, CV_64F                 op       연산 방법                 MORPH_OPEN       열기 동작                 MORPH_COLOSE       닫기 동작                 MORPH_GRADIENT       a morphological gradient. Diation과 Erosion의 차이                 MORPH_TOPHAT       “top hat”, Opening과 원본 이미지의 차이                 MORPH_BLACKHAT       “black hat”, Closing과 원본 이미지의 차이                 kernel       structuring element. cv2.getStructuringElemet() 함수로 만들 수 있음                 anchor       structuring element의 중심. default(-1,-1)로 중심점                 iterations       erosion과 dilation 적용 횟수                 borderType       픽셀 외삽법 borderInterpolate 참고(https://github.com/MagnusBai/notes/wiki/opencv-borderType-pixel-extrapolation-method)                 borderValue       테두리 값           !wget -O opening.png https://docs.opencv.org/4.5.2/opening.png !wget -O closing.png https://docs.opencv.org/4.5.2/closing.png   --2021-10-25 09:49:19--  https://docs.opencv.org/4.5.2/opening.png Resolving docs.opencv.org (docs.opencv.org)... 172.67.218.21, 104.21.24.86, 2606:4700:3034::ac43:da15, ... Connecting to docs.opencv.org (docs.opencv.org)|172.67.218.21|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 2082 (2.0K) [image/png] Saving to: ‘opening.png’  opening.png         100%[===================&gt;]   2.03K  --.-KB/s    in 0s        2021-10-25 09:49:19 (27.1 MB/s) - ‘opening.png’ saved [2082/2082]  --2021-10-25 09:49:19--  https://docs.opencv.org/4.5.2/closing.png Resolving docs.opencv.org (docs.opencv.org)... 172.67.218.21, 104.21.24.86, 2606:4700:3034::ac43:da15, ... Connecting to docs.opencv.org (docs.opencv.org)|172.67.218.21|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 2205 (2.2K) [image/png] Saving to: ‘closing.png’  closing.png         100%[===================&gt;]   2.15K  --.-KB/s    in 0s        2021-10-25 09:49:19 (20.8 MB/s) - ‘closing.png’ saved [2205/2205]   opening = cv2.imread('/content/opening.png') cv2_imshow(opening)      opening = cv2.morphologyEx(opening, cv2.MORPH_OPEN, kernel) cv2_imshow(opening)      closing = cv2.imread('/content/closing.png') cv2_imshow(closing)      closing = cv2.morphologyEx(closing, cv2.MORPH_CLOSE, kernel) cv2_imshow(closing)      Morphological Gradient      dilation과 erosion의 차이   gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel) cv2_imshow(gradient)      Top Hat     입력 이미지와 opening 이미지와의 차이   tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel) cv2_imshow(tophat)      Black Hat     입력 이미지와 closing 이미지와의 차이   blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel) cv2_imshow(blackhat)      Structuring Element      사각형 모양의 structuring element는 numpy를 통해 만들 수 있음   kernel = np.ones((5,5), np.uint8)   kernel   array([[1, 1, 1, 1, 1],        [1, 1, 1, 1, 1],        [1, 1, 1, 1, 1],        [1, 1, 1, 1, 1],        [1, 1, 1, 1, 1]], dtype=uint8)      원이나 타원 모양이 필요한 경우, cv2.getStructuringElement() 이용            Parameters                    shape : Element의 모양.                            MORPH_RET : 사각형 모양               MORPH_ELLIPSE : 타원형 모양               MORPH_CROSS : 십자 모양                                   ksize : structuring element 사이즈                           rect_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5)) rect_kernel   array([[1, 1, 1, 1, 1],        [1, 1, 1, 1, 1],        [1, 1, 1, 1, 1],        [1, 1, 1, 1, 1],        [1, 1, 1, 1, 1]], dtype=uint8)   ellipse_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5)) ellipse_kernel   array([[0, 0, 1, 0, 0],        [1, 1, 1, 1, 1],        [1, 1, 1, 1, 1],        [1, 1, 1, 1, 1],        [0, 0, 1, 0, 0]], dtype=uint8)   cross_kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5)) cross_kernel   array([[0, 0, 1, 0, 0],        [0, 0, 1, 0, 0],        [1, 1, 1, 1, 1],        [0, 0, 1, 0, 0],        [0, 0, 1, 0, 0]], dtype=uint8)   gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, rect_kernel) cv2_imshow(gradient)      gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, ellipse_kernel) cv2_imshow(gradient)      gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, cross_kernel) cv2_imshow(gradient)      이미지 기울기(Image Gradients)      Gradient(기울기)는 영상의 edge 및 그 방향을 찾을 때 활용됨   이미지(x,y)에서의 벡터값(밝기와 밝기의 변화하는 방향)을 구해서 해당 pixel이 edge에 얼마나 가까운지, 그 방향이 어디인지 알 수 있음   Sobel &amp; Scharr Filter   cv2.Sobel()      Gaussian smoothing과 미분을 이용   노이즈가 있는 이미지에 적용하면 좋음   X축과 Y축을 미분하는 방법으로 경계값을 계산                  파라미터       설명                       src       input image                 ddepth       output image의 depth, -1 이면 input image와 동일                 dx       x축 미분 차수                 dy       y축 미분 차수                 ksize       kernel size(ksize x ksize)              cv2.Scharr() : cv2.Sobel()과 동일 하지만 ksize()가 soble의 3x3보다 정확하게 적용됨   !wget -O travel.jpg https://c1.wallpaperflare.com/preview/49/805/166/airport-flights-scoreboard-flight.jpg   --2021-10-25 09:49:20--  https://c1.wallpaperflare.com/preview/49/805/166/airport-flights-scoreboard-flight.jpg Resolving c1.wallpaperflare.com (c1.wallpaperflare.com)... 104.21.2.147, 172.67.129.81, 2606:4700:3031::ac43:8151, ... Connecting to c1.wallpaperflare.com (c1.wallpaperflare.com)|104.21.2.147|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 111173 (109K) [image/jpeg] Saving to: ‘travel.jpg’  travel.jpg          100%[===================&gt;] 108.57K  --.-KB/s    in 0.02s     2021-10-25 09:49:20 (4.89 MB/s) - ‘travel.jpg’ saved [111173/111173]   img = cv2.imread('/content/travel.jpg', 0) img.shape   (607, 910)   plt.imshow(img, 'gray') plt.show()      sobelx = cv2.Sobel(img, cv2.CV_8U, 1, 0, ksize=3) plt.imshow(sobelx, 'gray') plt.show()      sobely = cv2.Sobel(img, cv2.CV_8U, 0, 1, ksize=3) plt.imshow(sobely, 'gray') plt.show()      sobelx2 = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=5) plt.imshow(sobelx2, 'gray') plt.show()      sobely2 = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=5) plt.imshow(sobely2, 'gray') plt.show()      Laplacian 함수   cv2.Laplacian()      이미지의 가로와 세로에 대한 Gradient를 2차 미분한 값   Sobel filter에 미분의 정도가 더해진 것과 비슷함   (dx와 dy가 2인 경우) blob(주위의 pixel과 확인한 pixel 차이를 나타내는 덩어리) 검출에 많이 사용됨                  파라미터       설명                       src       source image                 ddepth       output image의 depth           plt.imshow(img, 'gray') plt.show()      laplacian = cv2.Laplacian(img, cv2.CV_8U) plt.imshow(laplacian, 'gray') plt.show()      laplacian2 = cv2.Laplacian(img, cv2.CV_64F) plt.imshow(laplacian2, 'gray') plt.show()      Canny Edge Detection   cv2.Canny()      가장 유명한 Edge Detection 방법   Noise Reduction            이미지의 Noise를 제거       이때 5x5의 Gaussian filter를 이용           Edge Gradient Detection            이미지에서 Gradient의 방향과 강도를 확인       경계값에서는 주변과 색이 다르기 때문에 미분값이 급속도로 변하게 됨       이를 통해 경계값 후보군을 선별           Non-maximun Suppression            이미지의 pixel을 Full scan하여 edge가 아닌 pixel은 제거           Hysteresis Thresholding            edge로 판단된 pixel이 진짜 edge인지 판별하는 작업 진행       maxVal과 minVal(임계값)을 설정하여 maxVal 이상은 강한 edge, min과 max 사이는 약한 edge로 설정       약한 edge가 진짜 edge인지 확인하기 위해 강한 edge와 연결이 되어 있으면 edge로 판단하고 그렇지 않으면 제거                                      파라미터           설명                                           image           8-bit input image                             threshold1           Hysteresis Thredsholding 작업에서의 min 값                             threshold2           Hysteresis Thredsholding 작업에서의 max 값                           plt.imshow(img, 'gray') plt.show()      canny = cv2.Canny(img, 30, 70) plt.imshow(canny, 'gray') plt.show()      ","categories": [],
        "tags": ["Image Processing","Matplotlib","OpenCV"],
        "url": "/20211025/",
        "teaser": "/assets/images/20211025/0_.png"
      },{
        "title": "방사선 기술 요소(Technical Factors of Radiology)",
        "excerpt":"     방사선 촬영 기술이란 무엇인가?   kVp가 방사선 영상에 어떤 영향을 미치는가?   mAs가 방사선 영상에 어떤 영향을 미치는가?   노출 시간이 방사선 영상에 어떤 영향을 미치는가?        역제곱 법칙과 방사선 촬영 기술 간의 관계는 무엇인가?       X선 노출의 세 가지 주요 구성 요소            kVp: X선 빔의 파워와 세기(X선의 품질)       mAs: 선택한 설정(X선 수량)에서 X선 튜브에 의해 생성된 X선 광자의 수       Time: 노출 지속 시간           기술의 이해   kVp는 킬로볼트의 피크(Kilo Volt Peak)를 나타낸다. 이 전압은 노출 중에 X선 기계에 의해 생성되는 최고 전압(수천 볼트 단위로 측정)이다. 예를 들어, 60kVp를 선택한 경우 60,000볼트가 이 노출에서 생성된 X선의 최대 강도가 된다. 70kVp를 선택한 경우 70kVp가 최대 강도가 된다.   kVp는 X선 빔의 투과 강도를 제어한다.(빔 품질) 노출이 이루어질 때마다 X선은 관심 영역을 충분히 투과할 수 있는 에너지(충분히 강한)여야 한다. kVp가 높을수록 X선 빔이 두껍거나 밀도가 높은 물질을 투과할 가능성이 높아진다. 낮은 kVp광자는 약하고 배치된 신체 조직이나 필터에 쉽게 흡수된다. 더 높은 kVp광자는 환자의 조직을 관통하여 X선 필름까지 도달한다. 의료 영상에 사용되는 대부분의 X선은 50-120kVp(50,000~120,000볼트)이다.                  적정 kVp       신체 부위                       55 - 60       손가락, 손, 손목                 65 - 75       어깨, 무릎                 75 - 80       엉덩이, 복부, 골반                 90 - 100       요추           신체 부위의 두께와 노출되는 조직의 종류에 따라 어떤 kVp를 선택할지 결정한다. 예를 들어, 손가락, 손 또는 손목은 신체 부위가 얇고 X선이 투과할 신체 조직이 많지 않기 때문에 낮은 kVp설정만 필요하다. 일반적으로 55-60kVp 사이의 설정이 선택된다. 어깨나 무릎은 손가락보다 두껍고 밀도가 높기 때문에 적절히 침투하기 위해서는 더 많은 kVp가 필요하다. 보통 65-75kVp 범위의 설정은 이러한 바디 구조에서 선택된다. 엉덩이, 복부 및 골반은 무릎이나 어깨보다 더 두껍고 촘촘하다. 적절한 침투에는 추가 kVp가 필요하다. 75-80kVp 범위의 설정을 사용할 수 있다. 요추는 매우 두껍고 밀도가 높기 때문에 90-100kVp 범위에서 설정해야 한다.      캘리퍼스(상단 이미지)는 이미징 중인 신체 부위의 두께를 측정하는데 사용된다. 일반적으로 조직 두께가 1cm 추가될 때마다 2kVp가 증가해야 적절한 용입이 보장된다. 예를 들어, 60kVp를 사용하여 10cm로 측정된 신체 부위의 허용 이미지를 얻은 경우 11cm 로 측정된 신체 부위를 투과하기 위해서는 2kVp가 필요하다.(두께가 추가될 때마다 2kVp 증가, 즉 62kVp) 신체 부위의 치수가 12cm인 경우 64kVp를 사용해야 한다.   kVp는 또한 X선에서 볼 수 있는 대비(이미지의 흰색과 검은색의 차이)를 제어한다. 영상에서 볼 수 있는 대비의 양을 그레이 스케일(Gray Scale)이라고 한다.     이미지의 대비가 높으면 필름에 회색 음영이 거의 없어지고 흰색과 검은색 영역이 뚜렷이 구분된다.   필름의 대비가 낲으면 매우 밝은 것부터 매우 어두운 것까지 수많은 회색 음영이 나타난다. 저대비 영상은 각 그레이 스케일 단계에서 미묘한 변화가 있다.      위 이미지는 알루미늄 스텝 웨지의 X선을 보여준다. 스텝 웨지는 신체 부위가 두꺼울수록 통과할 수 있는 X선이 적다는 것을 보여준다. 또한 선택한 kVp에 따라 명암비가 어떻게 변화하는지 보여준다. 고대비 영상에는 흰색과 검은색은 있지만, 적은 회색 음영(낮은 kVp)이 있는 반면, 저대비 영상에는 높은 회색 음영(높은 kVp)이 있다. 이 스텝 웨지는 40kVp(맨 왼쪽), 70kVp(가운데) 및 100kVp(맨 오른쪽)의 3 가지 설정을 사용하여 공개되었다. 대비의 차이를 쉽게 알 수 있다. 알루미늄 스텝 웨지 아래에 X선 필름 시트를 배치하여 노광한다. 각 계단 단계 밀도의 변화는 필름의 어두운 정도를 측정하는 미터인 감도계를 사용하여 기록된다. kVp가 높아지면 방사선 대비가 낮아진다. kVp가 증가하면 이미지의 전체적인 밀도(어두움)도 증가한다. kVp의 미세 조정은 이미지에 큰 영향을 미칠 수 있다. kVp가 15% 증가하면 mAs가 약 2배가 된다. 반대로 kVp의 15% 감소는 mAs를 절반으로 줄이는 것과 같다. kVp 설정이 높을수록 더 많은 산란 방사선이 생성된다. 산란이 증가하면 영상 디테일이 줄어들고 환자 선량이 증가한다. 다음과 같은 결과를 얻을 수 있는 노출에 사용할 수 있는 kVp 설정을 항상 결정해야 한다.     적절한 신체 부위 침투   가능한 한 최소의 산란 생성량   가능한 한 높은 방사선 대비   이미지 상세 표시 가능   기술 차트   기술 차트는 다양한 시험에 사용되는 평균 kVp, mA, 시간, 거리 및 필름 유형을 나열하도록 개발되었다. 기본적으로 너무 어둡거나 너무 밝거나 너무 많이 침투한 필름을 촬영하는 대신 방사선 기술자가 첫 번째 노출에서 최적의 이미지를 생성하는데 도움을 주기 위한 참조이다. 많은 병원과 클리닉에서는 최적의 고정 kVp가 각 신체 부위에 할당되어 최상의 침투와 대비가 달성되도록 하고 환자의 크기에 따라 mAs를 조정하도록 기술 차트를 설정한다. 이를 고정 kVp 시스템이라고 한다. 일부 최신 장비는 노출 매개변수를 내장하여 기술자가 기술 차트를 덜 활용할 수 있도록 자동으로 설정된다.      위 이미지는 매개 변수 차트가 표시된 X선 제어 콘솔이다.                  Exam       kVp       mA       time       mAs       distance       film/screen       grid                       Upper Extremity                                                                         Finger       50       100       0.02       2       40”       detail       no                 Hand       50       100       0.03       3       40”       detail       no                 Wrist       54       100       0.02       2       40”       detail       no                 Forearm       54       100       0.025       2.5       40”       rare earth       no                 Elbow       60       100       0.03       3       40”       detail       no                 Humerus       72       100       0.06       6       40”       rare earth       yes                 Clavicle       64       100       0.04       4       40”       rare earth       yes                 Shoulder- AP       76       200       0.04       8       40”       rare earth       yes                 Shoulder- axillary       76       300       0.08       24       40”       rare earth       yes                 Shoulder- Y view       76       300       0.1       30       40”       rare earth       yes                                                                                           Lower Extremity                                                                         Toe       50       100       0.016       1.6       40”       detail       no                 Foot       54       100       0.032       3.2       40”       detail       no                 Calcaneous       64       200       0.04       8       40”       detail       no                 Ankle       62       100       0.04       4       40”       detail       no                 Lower Leg       64       100       0.025       2.5       40”       rare earth       no                 Knee       66       200       0.03       6       40”       rare earth       yes                 Sunrise Patella       66       100       0.04       4       40”       rare earth       no                 Femur       70       200       0.04       8       40”       rare earth       yes                 Hip- AP       75       300       0.1       30       40”       rare earth       yes                 Hip- x-table lateral       80       400       0.2       80       40”       rare earth        yes                                                                                           Spine                                                                         Cervical x-table lat       76       200       0.1       20       72”       rare earth       yes                 Cervical- AP       74       100       0.1       10       40”       rare earth       yes                 Odontoid       70       100       0.04       4       40”       rare earth       no                 Swimmer’s lateral       80       500       0.3       150       40”       rare earth       yes                 T-spine AP       74       200       0.07       14       40”       rare earth       yes                 T-spine lateral       66       300       0.5       150       40”       rare earth       yes                 L-spine AP       75       400       0.1       40       40”       rare earth       yes                 L-spine lateral       90       400       0.4       160       40”       rare earth       yes                                                                                           Chest                                                                         Chest PA       110       500       0.02       10       72”       chest detail       yes                 Chest lateral       110       500       0.08       40       72”       chest detail       yes                 Chest newborn       55       100       0.01       1       40”       rare earth       no                 Chest 1 year old       60       100       0.01       1       40”       rare earth       no                 Chest 6 year old       60       100       0.03       3       40”       rare earth       no                                                                                           Abdomen                                                                         KUB       70       300       0.1       30       40”       rare earth       yes                 Lateral decubitus       80       400       0.05       40       40”       rare earth       yes                 KUB 2 year old       66       100       0.05       5       40”       rare earth       no                                                                                     약 81.6kg(180파운드) 평균 체격 남성 기준의 차트     상세: 100배속 필름/스크린 시스템   희토류: 400배속 필름/스크린 시스템   그리드: 103lp/inch 8:1 초점   반값 레이어   X선 빔의 투과 능력(품질)은 노출을 위해 선택된 kVp에 따라 달라진다. 반값 테스트를 수행하여 재료를 통해 투과되는 X선 광자의 수를 원래 수의 절반으로 줄이는 데 필요한 재료의 두께를 결정할 수 있다. 반값층을 결정하기 위해 일반적으로 사용되는 재료는 알루미늄이다. 알루미늄, 납, 바륨 또는 요오드와 같은 밀도가 높은 물질의 얇은 층만이 반값 층을 줄일 수 있다. X선 빔에 동일한 효과를 내려면 밀도가 낮은 재료(목재, 유리, 종이, 골판지 등)의 두꺼운 층이 필요하다.   현대의 이미징 부서에서 반 값 계층에는 두 가지 중요한 애플리케이션이 있다. 첫 번째는 환자 진단에 사용되는 기본 X선 빔의 절반 값 레이어다. 진단용 X선 빔은 광범위한 에너지를 생성한다. 빔의 최대 에너지(예를 들어 노출에 80kVp를 사용한다고 하는 경우)만 언급하지만 빔은 80kVp 이하의 광자로 구성된다. 우리는 빔에 낮은 에너지 광자를 원하지 않는다. 우리는 단지 80의 에너지를 가진 광자를 원한다. 모든 광자가 80kVp를 가진 완벽한 X선 빔을 얻을 수 있는 방법은 없다. 단, 반값 레이어는 낮은 에너지 광자(이 예에서는 80kVp 미만)를 필터링 하는데 도움이 된다.   기본적으로 특정 X선 빔의 절반 값 레이어가 낮은 경우(얇은 알루미늄 필터 조각), X선 빔에는 80kVp 미만의 낮은 에너지 광자가 더 많이 포함된다. 그들은 또한 에너지가 낮기 때문에 침투력이 적다. 반값 레이어가 높은 경우(두꺼운 알루미늄 추가), 낮은 에너지 광자가 두꺼운 알루미늄을 투과 할 수 없기 때문에 X선 빔에는 높은 에너지 또는 높은 투과 방사선이 포함되어 있다. 의료용 X선에 사용되는 X선은 관심 신체 부위를 투과하여 필름을 충분히 노출할 수 있는 충분한 에너지를 가지고 있어야 하기 때문에 이것은 중요하다. 저에너지 방사선은 환자의 조직으로 흡수되거나 신체에 의해 산란되어 필름에 도달하지 못할 수 있으며 이미지에 아무런 도움이 되지 않는다. 일반적으로 장치 제조업체가 설치 전에 수행하는 빔에 필터를 더 추가하면 바람직하지 않은 저에너지 X선이 제거되는 동시에 바람직한 고에너지 X선이 환자를 통해 필름으로 전달된다. 반면 빔에 필터가 너무 많으면 X선 영상의 대비가 손실된다.(차분 흡수가 감소) 그렇기 때문에 물리학자는 모든 X선 장비를 1년에 한 번 정기적으로 평가하고 그 테스트의 일부로 반값 레이어를 측정한다.   이미지 부서에서 반값 레이어의 두번째 적용은 방사선실 차폐와 관련이 있다. X선 장비가 있는 방사선실은 일반적으로 납으로 된 벽으로 차폐되어 부서 내에서 X선 사용으로 인한 작업자 및 일반인에 대한 방사선 노출을 줄인다. 방사선실의 차폐를 설계할 때 물리학자는 X선 빔의 반값 레이어를 기반으로 계산을 수행한다. 일반적으로 설계에서는 실내 외부의 방사선 피폭을 허용 가능한 수준으로 줄이기 위해 충분한 반값 차폐층을 요구한다.   차이   kVp는 이미지에서 흰색, 검은색 및 회색 음영의 차이로 정의되는 방사선 대비를 제어한다. 눈으로 볼 때 대비는 이미지에서 가장 어두운 검은색과 가장 밝은 흰색 사이에 보이는 다른 색조의 수이다. 최적의 이미지를 만들기 위해서는 다양한 조직의 차이를 이상이나 병리학적 과정과 함께 구별할 수 있도록 일정한 대비가 필요하다.     콘트라스트가 높은 경우는, 화상에 흰색과 검은색이 나타나지만, 중간에는 회색 음영이 거의 없다. 이를 쇼트스케일 콘스라스트 또는 좁은 콘트라스트 위도라고 한다.   콘트라스트가 낮은 경우는, 회색의 음영이 다수 있어, 각각의 음영에 거의 차이가 없다. 이미지가 평면으로 표시된다. 이를 롱스케일 콘트라스트 또는 와이드 콘트라스트 위도라고 한다.             위 이미지의 위 행은 3개의 흑백 이미지에서 대비 차이를 비교한 것이며, 아래 행은 세 가지 컬러 사진에서의 대비 차이를 비교한 것이다. 위의 이미지에서 고대비와 저대비의 차이를 쉽게 알 수 있다. 농도(어두움)는 변경되지 않고 각 사진에서 대비만 조정되었다.     두 줄의 왼쪽 이미지(낮은 대비)는 회색의 비슷한 음영과 회색의 음영 차이가 거의 없는 밀도로 구성되어 있다.   양쪽 행의 중간 이미지는 중간 정도의 대비를 나타낸다.   오른쪽 이미지(고대비)는 가장 밝은 부분과 가장 어두운 부분의 차이는 크지만 중간에는 회색 음영이 거의 없다.       위 손가락의 X선 이미지에서도 대비의 차이를 쉽게 볼 수 있다.     좌측은 높은 대비의 이미지다. 필름의 밝은 부분과 어두운 부분의 차이는 크고 회색의 색조는 거의 없다.   우측은 낮은 대비의 이미지다. 이미지는 평평하고 회색으로 보인다. 이 이미지의 가장 밝은 부분과 가장 어두운 부분에는 거의 차이가 없다. 낮은 대비 영상은 일반적으로 더 높은 kVp 설정을 사용하거나 두껍고 밀도가 높은 신체 조직이 원인이 된다.   방사선 영상에 영향을 미치는 몇 가지 대조도 유형이 있다.     필름 대비: 디지털 플레이트 시스템의 필름, 화면 또는 설정은 방사선 영상이 대비 스펙트럼의 이 부분을 제어하도록 하는데 사용된다. 필름/스크린 또는 디지털 설정의 특정 조합은 고대비 이미지(흑백은 거의 없지만 회색 음영)를 생성하도록 설계되어 있는 반면, 다른 시스템은 평평한 대비(회색 음영은 많으나 검은색 또는 흰색은 거의 없음)의 이미지를 생성하도록 설계되어 있다.   방사선 대비: 방사선 대비의 양은 필름 대비, 피사체 대비 및 노출에 대해 선택된 kVp의 조합에 의해 결정된다. 방사선 대비는 방사선 영상에서 볼 수 있는 광학 밀도의 전체적인 차이로 정의된다. 방사선 대비는 이미지 내의 미세한 디테일을 선명하게 볼 수 있도록 한다.   피사체 대비: 환자의 신체 조직이 빔에 영향을 미치는 영향(감쇠)의 차이로 인해 X선 광자가 환자를 통과할 때 X선 빔의 강도에 많은 변화가 발생한다. 이것을 피사체 대비라고 한다. 예를 들어, 매우 무거운 환자에게서 얻은 방사선 영상은 지방 조직이 피사체 대조도를 크게 낮추기 때문에 가벼운 환자보다 피사체 대조도가 낮다.   영상에서 피사체 대비의 전체 양을 결정하는 요인은 다음 4가지이다.     대상자(환자)의 구조 및 구성   kVp 선택   빔 여과량(추가로 추가)   피폭 시 발생하는 콤프턴(Compton) 산란의 양   시간   실제 X선 노출의 길이는 대부분의 X선 콘솔에서 기술자가 설정할 수 있다. 시간은 양질의 이미지를 만드는데 중요한 역할을 한다. 시간은 영상이 노출되는 시간을 결정하기 때문에 필름의 밀도에 직접적인 영향을 미친다.     선택한 시간이 너무 길면 이미지가 너무 어두울 수 있다. 노출 시간이 길면 짧은 시간을 사용했더라면 제거되었을 이미지에 움직임이 있을 수 있다는 단점이 있다.   반대로 노출 시간이 너무 짧으면, 화상이 너무 밝을 수 있다.   대부분의 일상적인 X선에는 10밀리초(0.01) 이하의 노출 시간이 권장된다. 일반적으로 모션 아티팩트를 줄이기 위해 노출에 가장 짧은 노출 시간과 가장 높은 mA를 함께 사용해야 한다.   mAs   mAs는 밀리암페어초를 나타낸다. 생성되는 X선 광자의 수(수량)을 결정한다. 이 값은 X선 광자의 강도(투과력)에는 영향을 미치지 않는다. mAs는 시간과 mA(밀리암페어)라는 두 가지 요소를 곱한 결과이다.   mA x Time(Sec) = mAs   예를 들어, 부상당한 손을 촬영하는데 사용되는 일반적인 기술 설정은 60kVp, 100mA 및 1/100초(0.01)일 수 있다. 이 예에서 100mA에 0.01초를 곱하면 1mAs(또는 1밀리암페어초)가 된다. 또 다른 예에서는 어깨를 촬영하는 경우 70kVp, 200mA 및 1/10초로 기술적 계수를 설정할 수 있다. mAs를 구하려면 200 x 1/10(0.10)을 곱하면 20mAs가 된다.       mAs 계산                  Sec \\ mA       50 mA       100 mA       150 mA       200 mA       300 mA       400 mA       500 mA       600 mA                       .003 sec       .15 mAs       .3 mAs       .45 mAs       .6 mAs       .9 mAs       1.2 mAs       1.5 mAs       1.8 mAs                 .006 sec       .3 mAs       .6 mAs       .9 mAs       1.2 mAs       1.8 mAs       2.4 mAs       3 mAs       3.6 mAs                 .010 sec       .5 mAs       1 mAs       1.5 mAs       2 mAs       3 mAs       4 mAs       5 mAs       6 mas                 .016 sec       .8 mAs       1.6 mAs       2.4 mAs       3.2 mAs       4.8 mAs       6.4 mAs       8 mAs       9.6 mAs                 .020 sec       1 mAs       2 mAs       3 mAs       4 mAs       6 mAs       8 mAs       10 mAs       12 mAs                 .025 sec       1.25 mAs       2.5 mAs       3.75 mAs       5 mAs       7.5 mAs       10 mAs       12.5 mAs       15 mAs                 .032 sec       1.6 mAs       3.2 mAs       4.8 mAs       6.4 mAs       9.6 mAs       12.8 mAs       16 mAs       19.2 mAs                 .040 sec       2 mAs       4 mAs       6 mAs       8 mAs       12 mAs       16 mAs       20 mAs       24 mAs                 .050 sec       2.5 mAs       5 mAs       7.5 mAs       10 mAs       15 mAs       20 mAs       25 mAs       30 mAs                 .064 sec       3.2 mAs       6.4 mAs       9.6 mAs       12.8 mAs       19.2 mAs       25.6 mAs       32 mAs        38.4 mAs                 .048 sec       4 mAs       8 mAs       12 mAs       16 mAs       24 mAs       32 mAs       40 mAs       48 mAs                 .10 sec       5 mAs       10 mAs       15 mAs       20 mAs       30 mAs       40 mAs       50 mAs       60 mAs                 .12 sec       6 mAs       12 mAs       18 mAs       24 mAs       36 mAs       48 mAs       60 mAs       72 mAs                 .14 sec       7 mAs       14 mAs       21 mAs       28 mAs       42 mAs       56 mAs       70 mAs       84 mAs                 .16 sec       8 mAs       16 mAs       24 mAs       32 mAs       48 mAs       64 mAs       80 mAs       96 mAs                 .18 sec       9 mAs       18 mAs       27 mAs       36 mAs       54 mAs       72 mAs       90 mAs       108 mAs                 .20 sec       10 mAs       20 mAs       30 mAs       40 mAs       60 mAs       80 mAs       100 mAs       120 mAs                 .25 sec       12.5 mAs       25 mAs       37.5 mAs       50 mAs       75 mAs       100 mAs       150 mAs       150 mAs                 .32 sec       16 mAs       32 mAs       48 mAs       64 mAs       96 mAs       128 mAs       160 mAs       192 mAs                 .40 sec       20 mAs       40 mAs       60 mAs       80 mAs       120 mAs       160 mAs       200 mAs       240 mAs                 .50 sec       25 mAs       50 mAs       75 mAs       100 mAs       150 mAs       200 mAs       250 mAs       300 mAs                 .64 sec       32 mAs       64 mAs       96 mAs       128 mAs       192 mAs       256 mAs       320 mAs       384 mAs                 .80 sec       40 mAs       80 mAs       120 mAs       160 mAs       240 mAs       320 mAs       400 mAs       480 mAs                 1 sec       50 mAs       100 mAs       150 mAs       200 mAs       300 mAs       400 mAs       500 mAs       600 mAs                 1.6 sec       60 mAs       160 mAs       240 mAs       320 mAs       480 mAs       640 mAs       800 mAs       960 mAs                 2 sec       100 mAs       200 mAs       300 mAs       400 mAs       600 mAs       800 mAs       1000 mAs       1200 mAs                 3.2 sec       160 mAs       320 mAs       480 mAs       640 mAs       960 mAs       1280 mAs       1920 mAs       1920 mAs                 5 sec       250 mAs       500 mAs       750 mAs       1000 mAs       1500 mAs       2000 mAs       4800 mAs       3000 mAs           mAs는 검사 대상 신체 부위의 크기와 조직 유형에 따라 조정된다. mAs는 노출에 사용된 시간 또는 mA(밀리암페어) 설정을 변경하여 변경할 수 있다. mA와 시간의 조합은 여러 가지가 있으며, 함께 곱하면 동일한 mAs가 된다. 예를 들어 다음과 같은 mA와 시간의 조합은 모두 100mAs와 동일하다.                  mA       Time       mAs                       50mA       2Sec       100mAs                 100mA       1Sec       100mAs                 200mA       1/2Sec       100mAs                 400mA       1/4Sec       100mAs                 500mA       1/5Sec       100mAs           위의 노출은 결과 X선 필름에서 동일한 밀도를 생성한다. 어린 아이의 경우처럼 환자가 가만히 있는데 어려움이 있는 경우 노출 시간을 단축해야 한다. 짧은 노출 시간과 높은 mA설정을 사용하는 경우 튜브 정격 차트를 참조하여 튜브가 이러한 노출로 인해 발생하는 극한 온도에 견딜 수 있는지 확인해야 한다. 위의 예에서 선택될 수 있는 5가지 조합에 관계없이 각 조합은 정확히 동일한 수의 X선 광자를 생성한다. 이러한 조합으로 생성된 영상은 방사선 밀도가 동일하다.(이미지 검어짐의 양) mAs는 이미지의 농도(어두움)를 제어하는데 가장 중요한 기술적 요소이다.   mAs에 관한 규칙      mAs는 환자 노출률에 정비례한다.   mAs가 2배 증가하면 2배의 X선 광자가 생성되고 환자는 2배의 방사선량을 받게 된다.   이미지에서 지각 가능한 변화를 일으키려면 mAs를 30% 이상 조정해야 한다.   mAs는 필름의 밀도를 담당하며 X선 튜브에 의해 생성되는 X선 광자 수를 제어한다.   mAs는 X선 광자의 강도(투과력)에 영향을 주지 않는다.   영상에서 지각 가능한 변화를 일으키려면 mAs를 30% 이상 조정해야 한다. 상당한 농도 변화가 필요한 경우 최소 50%의 노출 조정이 필요하다. 20mAs를 사용하여 엉덩이 영상을 얻은 경우 필름의 밝기가 너무 낮으면 mAs를 늘리면 필름의 색이 어두워진다. 24mAs까지만 증가해도 모양에 큰 차이는 없다. 첫 번째 증가율은 30% 이상이어야 하기 때문이다.(이 예에서는 약 27mAs) 영상이 매우 밝으면 원래 노출에서 mAs(40mAs)를 두 배로 늘려야 할 수 있다.   15% 규칙   mAs는 주로 밀도를 제어하지만 kVp의 변화는 이미지 밀도의 원인이 되기도 한다. 15% 규칙에서는 kVp가 15% 증가하면 mAs를 두 배로 증가하는 것과 비슷하다. 반대로 kVp가 15% 감소하면 mA를 반으로 줄어드는 것과 비슷하다.   kVp가 변경되면 이미지 밀도에 영향을 미치지만 주로 이미지 대비가 변경된다. kVp의 주요 역할은 X선 빔의 강도와 전력 및 대비를 제어하는 것이다. 가능하면 mAs를 사용하여 kVp가 아닌 영상의 전체 밀도(어두움)를 증가 또는 감소시켜야 한다. 기술 설정을 조정할 때는 처음부터 둘다 변경하지 말고 둘 중 하나(kVp 또는 mAs)만 조정해야 한다.      배경을 포함한 전체 이미지가 너무 밝은 노출할 경우 mAs만 증가한다.   필름이 전체적으로 너무 어두운 경우 mAs를 줄인다.   필름의 침투가 부족할 경우(조직이 보이지 않을 경우) kVp를 높인다. 침투되지 않는 영상과 일부 조직의 배경은 허용 가능한 밀도를 가지지만 관심 영역(예: 뼈)은 세부 정보가 거의 또는 전혀 없이 씻겨나간 것처럼 보인다.   필름이 과도하게 침투되면 배경을 포함한 전체 필름에 흰색 또는 검은색 영역이 거의 없거나 아예 없다. 모든 부분이 회색이 된다. 그러한 이미지에서 X선은 너무 강해서 대부분 환자를 관통하고 어떠한 차동 흡수도 일어나지 않는다. kVp를 줄인다.   이미지 밀도 변경      사람의 눈으로 인식할 수 있는 이미지의 밀도에 뚜렷한 차이를 만들기 위해서는 mAs를 최소 30% 이상 변화해야 한다.   밀도에 큰 변화가 필요한 경우 mAs를 최소 50% 이상 변경해야 한다.   과다 또는 과소 노출 필름의 노출을 보정하려면 mAs의 100%(2배 또는 절반으로 절단) 변화가 필요하다. 노출이 과도하거나 적은 반복 필름을 촬영할 때 매개 변수의 최소 변경량은 다음과 같아야 한다.            필름이 너무 가벼워 반복하는 이미지의 경우 mAs를 최소 2배 이상 증가시킨다.       필름이 너무 어두웠기 때문에 반복하는 필름의 mAs를 절반 이상 줄인다.           퀀텀 모틀   Quantum Mottle은 고속 또는 고속 필름/스크린 시스템을 사용할 때 가장 자주 나타나는 방사선 사진에 나타나는 결상이다. 스크린과 필름은 인광 또는 은 결정을 더 크게 하여(또는 결정츨이 더 두껍게/더 단단하게 포장되어 있음) 더 빠르게 제작된다. 따라서 통과 입사 X선이 결정과 상호작용할 가능성이 높아진다. 큰 결정은 작은 결정보다 더 많은 빛을 방출하기 때문에 더 많은 필름 영역을 어둡게 한다.   노출에 낮은 mAs를 사용하면 양자 얼룩이 발생할 수도 있다. mAs가 너무 낮게 설정되면 빔에 충분한 수의 결정과 상호 작용하기에 충분한 X선 광자가 없다. 그것은 약한 비를 큰 뇌우에 비유하는 것과 비슷하다.   거리   X선 튜브에서 필름까지의 거리(SID)는 고품질 X선을 생성하는데 중요한 구성 요소 중 하나이다. 거리는 mAs와 직접적인 관계가 있다. 엑스레이는 빛의 법칙을 모두 따르기 때문에, 간단한 운동을 함으로써 거리가 엑스레이에 어떻게 영향을 미치는지 더 잘 이해할 수 있다. 어두운 방으로 손전등을 가져가서 불빛을 벽에서 약 12인치 떨어진 곳에 두면, 빛에 가려진 영역이 매우 작고 잘 정의된 원임을 알 수 있다. 또한, 빛의 강도가 매우 강하고 밝다는 것을 알 수 있다. 이제 벽에서 천천히 거리를 두고 빛이 비치는 곳을 주시해보자. 거리를 늘리면서 빛의 세기에 주의하자. 거리가 커지면 빛의 세기도 작아진다. 동시에 빛에 의해 조명된 영역은 팬 아웃되고 벽의 더 많은 부분이 빛으로 덮여 있다.      엑스레이는 위의 유추에서 빛과 같은 방식으로 작동한다. X선 소스(X선 튜브)에서 영상 수용체(필름)까지의 거리가 증가하면 다음 두 가지 일이 발생한다.     X선 빔의 강도는 X선이 더 멀리 이동할수록 감소한다.   X선은 확산(집약)되어 소스로부터 멀리 이동할수록 점점 더 넓은 필드를 커버한다.   X선 소스(X선 튜브)와 이미지 수신기(필름) 사이의 거리를 소스-영상 거리(SID)라고도 하며, 초점 필름 거리(FFD)라고도 한다.   역제곱 법칙   역제곱 법칙은 강도와 거리 사이의 관계를 지배하는 자연 법칙이다. 그것은 에너지의 세기는 거리의 제곱에 반비례한다고 말한다. 아래 그림은 다소 복잡한 개념을 단순화하는데 도움이 될 수 있다.   거리가 짧을수록(40”) X선 빔의 명암은 높아진다. X-ray 빔은 그다지 멀리 이동하지 않았지만, 이미 약간 퍼지기 시작해 4개의 정사각형을 커버하고 있다. X선 빔이 약 2배의 거리(72인치)를 주행할 때까지 강도가 상당히 저하되어 빔이 16개의 정사각형을 커버할 수 있을 만큼 넓게 퍼지게 된다. 그것은 본질적으로 역제곱 법칙이다.        40인치에서는 사각형이 4개만 발산 X선 빔에 가려져 있다. 거리를 두 배(80인치)로 늘리면 16개의 정사각형이 커버된다. X선 튜브에서 영상 카세트까지의 거리를 두 배로 늘리면 발산 빔이 4배 더 많은 정사각형을 덮게된다.    이 예에서는 (40”)에서의 강도가 4mR이라고 한다. 나중에 다른 사진을 찍었는데, 이번에는 거리가 72인치로 거의 두 배 가까이 늘어났다. 역제곱 법칙에 따르면 첫 번째 이미지와 같은 밀도를 유지하려면 mAs 가 4배 더 필요하다. 따라서 동일한 밀도를 유지하려면 16mR이 필요하다.   또 다른 예에서는 방사선 노출을 측정하는 기기를 mR 단위로 배치하고 중심 빔이 중앙에 있는 환자의 피부에 배치했다고 가정하자. 40인치 SID를 사용하여 노출을 수행하면 측정값은 200mR이 된다. 현재는 동일한 기술 요소(kVp, mA 또는 시간 변경 없음)를 사용했지만 거리는 40인치에서 72인치로 거의 두 배 증가했다. 역제곱 법칙을 사용할 경우 이제 mR 판독값은 얼마일까? 거리를 두 배로 늘렸기 때문에 빔의 새로운 강도는 원래 강도의 1/4이 될 것이다. 따라서 200mR을 1/4(또는 25%)로 나누면 50mR이 된다.   SID(Subject to image)를 변경할 때는 다음 규칙에 유의해야 한다.     거리(SID)를 두배로 했을 때는, mAs의 양을 4배로 늘려 이미지의 같은 밀도를 유지할 필요가 있다.            예: 들것에 누워있는 환자에게 휴대용 흉부 필름 찍는다. 앙와위 필름은 일반적으로 40인치 SID를 사용하여 촬영한다. 기술을 2mAs로 설정하고 잘 노출된 필름을 얻는다. 의사는 환자의 폐에 체액이 쌓이는 것을 더 잘 볼 수 있도록 똑바로 서서 볼 필요가 있다고 말한다. 수직 필름이 72인치에서 촬영되기 때문에 SID 거리가 거의 두 배로 늘어난다. 역제곱 법칙을 사용하면 거리를 두 배로 늘렸기 때문에 4배의 강도가 필요하다는 것을 알 수 있다. 테크닉을 8mAs(2x4)로 설정하면 완벽한 수직 필름을 얻을 수 있다.           거리를 반으로 줄이면 (mAs)를 4배(이전 사용량의 1/4 사용)까지 줄일 수 있다.            예: 들것에 똑바로 앉아 있는 환자의 휴대용 흉부 필름을 찍는다. 72”의 SID를 사용하고 10mAs를 선택한다. 엑스레이는 잘 노출되어 있고 촬영 결과에 만족한다. 그날 오후 환자는 심각한 좌절을 겪으며 그의 상태는 급격히 악화된다. 이제 다른 흉부 필름을 구해야 한다. 이번에는 환자가 이전처럼 일어나 앉을 수 없으므로 SID 40”을 사용하여 반듯이 누운 필름을 촬영한다. 역제곱 법칙을 사용하면 mAs가 72인치에서 10이고 이제 거리를 40인치로 절반으로 줄이면 강도를 4배 줄여야 한다. 10을 1/4로 나눈 2.5mAs로 설정하면 완벽한 영상을 얻을 수 있다.           실제 상황에서 우리는 거리를 두 배로 늘리거나 반으로 줄여서 항상 바꾸지는 않는다. 종종 우리는 우리의 거리를 몇 인치만 바꾼다. 다음 표는 거리가 변경될 때 사용해야 하는 새 노출 계수를 결정하는데 사용할 수 있는 증배 계수이다.                  New\\Original SID       36”(91 cm)       40”(102 cm)       42”(107 cm)       44”(112 cm)       48”(122 cm)       60”(152 cm)       72”(183 cm)       100”(305 cm)                       36”(91 cm)       1       0.8       0.7       0.7       0.6       0.4       0.3       0.1                  40”(102 cm)       1.2       1       0.9       0.8       0.7       0.4       0.3       0.2                  42”(107 cm)       1.4       1.1       1       0.9       0.8       0.5       0.3       0.2                  44”(112 cm)       1.5       1.2       1.1       1       0.8       0.5       0.4       0.2                  48”(122 cm)       1.8       1.4       1.3       1.2       1       0.6       0.4       0.2                  60”(152 cm)       2.8       2.3       2       1.9       1.6       1       0.7       0.4                  72”(183 cm)       4       3.2       2.9       2.7       2.3       1.4       1       0.5                  100”(305 cm)       7.7       6.3       5.7       5.2       4.3       2.8       1.9       1               기존 SID와 변경된 SID간의 변환 계수를 찾는다.   기존 SID에서 사용한 mAs에 변환 계수를 곱한다.   새로운 mAs를 적용한다.   예를 들어, 10mAs를 사용하여 48인치로 필름을 촬영했다. 나중에 필름을 반복해야 하지만 다른 장비를 사용해야 하기 때문에 SID는 40인치만 얻을 수 있다 Original SID에서 48”를 찾는다. New SID와 교차할 때까지 이 열을 따라 40인치로 이동한다. 두 행이만나는 변환 계수는 0.7이다. 원래 mAs(10)를 취하여 0.7(10 x 0.7 = 7)을 곱한다. 40인치에서 새로운 mAs는 7이 된다.   유리섬유 또는 석고주조로부터의 노출 변화   단부에 주물을 배치하는 경우, 조밀한 주물 재료를 투과하고 광자를 흡수할 수 있는 재료가 더 많기 때문에 기술의 증가가 필요하다.                  Cast meterial &amp; size       Increase technique                       Fiberglass cast       add 3-4 kVp or increase mAs 25-30%                 Small to medium plaster cast       add 5-7 kVp or increase mAs 50-60%                 Large plaster cast       add 8-10 kVp or double mAs           관심 영역에 X선 빔을 콜리메이트하면 조사되는 조직의 부피가 줄어든다. 그 결과, 필름 노광의 산란 방사선이 적기 때문에, 환자의 노광이 저감 해 화질이 향상된다. 콜리메이션(필드 크기 감소라고도 함)은 필름을 노출하는 산란량을 감소시키므로 필름 밀도도 감소한다. 따라서 적절한 필름 밀도를 유지하기 위해 필드 크기를 줄일 경우 mAs 또는 kVp의 조정이 필요하다.   즉, 14x17인치 필름에 80kVp 및 40mAs를 사용하여 복부의 적절한 노출 이미지를 만든 다음 10x12인치 필름을 사용하여 복부의 특정 영역을 덮어야 하는 경우 80kVp 및 40mAs의 동일한 기술을 사용하면 필름은 너무 밝아진다. 더 작은 필드 크기로 콜리메이트하여 필름 밀도를 높여야 한다.   다음 표를 사용하여 필드 크기를 줄이거나 확대할 때 필요한 변경량을 계산할 수 있다.                  Exposure field size       Change in mAs required to maintain density       Multiplication factor                       Abdomen: Reducing field size from 14 x 17” film down to 10 x 12”       Increase mAs 25-35%       multiply mAs by 1.25 to 1.35                 Abdomen: Reducing field size from 14 x 17” down to 8 x 10”       Increase mAs 50-75%       multiply mAs by 1.5 to 1.75                 Abdomen: Increasing field size from 10 x 12” up to 14 x 17”       Reduce mAs 25-35%        multiply mAs by .25 to .35                 Abdomen: Increasing field size from 8 x 10” up to 14 x 17”       Reduce mAs 50-75%       multiply mAs by .50 to .75           예를 들어, 복부 14x17” 이미지에 80kVp 및 40mAs를 사용한 후 동일한 부위의 10x12” 이미지를 찍으면 매개 변수가 25-35% 증가한다. 40mAs x 1.25를 구하면 50이 된다. 50mAs를 사용하여 10x12” 노출을 수행해야 한다.   중앙선 각도 조정 시 노출 변경   영상의 밀도에 영향을 미치는 또 다른 요인은 특정 보기에 대해 중앙 광선의 각도를 조정해야 하는 위치에 있을 때 발생한다. SID가 40”이고 70kVp 및 80mAs를 사용하여 쇄골의 적절한 노출 이미지를 얻었다고 가정한다. 이제 영상 시르즈의 두 번째 보기에서 CR의 각도를 20도로 조정한다. 아래 그림에서 볼 수 있듯이 튜브의 앵글링으로 두 가지 작업을 수행했다. SID가 증가하여 이제 더 많은 신체 조직을 통해 침투하고 있다. 다음 두 가지 선택지가 있다.     SID를 다시 40인치로 줄여 동일한 노출 계수(70kVp 및 8mAs)를 유지한다.   거리를 그대로 두고 노출을 늘려 위의 표를 사용하여 추가 거리를 보정한다.       튜브의 각도를 조정할 때 밀도를 유지하는데 적용되는 기본 규칙은 각도가 5도일 때마다 SID가 1” 감소한다는 것이다. 이 규칙은 2인치 이상 증가 시 적용된다.(40인치에서 42인치 증가)                  CR Angle       Decreasing SID to maintain density                       5-10 degrees       1/2”                 15 degrees       1”                 20 degrees       2”                 25 degrees       3”                 30 degrees       4”                 35 degrees       6”                 40 degrees       8”           또는                  CR Angle       Increase in mAs is needed to maintain density w/o changing SID                       5-10 degrees       increase mAs by 10-20%                 15-25 degrees       increase mAs by 30-50%                 30-35 degrees       increase mAs by 75-100%                 40-45 degrees       increase mAs by 100-150%           주의할 점      광자의 신체 부위 투과 능력은 주로 그 부위(뼈, 연조직, 공기 등)의 구성과 존재할 수 있는 병리학에 의해 결정된다. 일부 조건은 신체 조직의 밀도를 감소시킨다.(예: 캐비티 또는 침식되는 골연화증) 이런 경우에는 X선이 더 쉽게 투과된다. 다른 조건에서는 복수와 같은 특정한 병리가 존재하기 때문에 신체 조직의 밀도가 증가한다. 이러한 경우 X선은 조직을 통해 쉽게 투과할 수 없다.   방사선 밀도는 mAs로 제어된다. 노출이 절반으로 줄어들면 방사선 밀도도 절반으로 줄어든다.   kVp는 밀도에도 영향을 미친다. kVp가 15% 감소하면 이미지의 밀도가 절반으로 줄어든다. 그러나 kVp를 변경하면 영상 대비 및 X선 빔의 투과력도 변경됨으로 kVp가 아닌 mAs를 변경하여 영상의 밀도를 조절해야 한다.   mAs(방사선 밀도를 조절하는)를 결정하는 공식은 mA x 노출 시간(초 단위) 또는 초 단위(초 단위) = mAs 이다.   역제곱 법칙은 방사선의 세기가 방사선이 이동하는 거리의 제곱에 반비례한다는 것이다. 따라서 X선 튜브와의 거리가 늘어날수록 X선 빔의 강도는 감소한다.  ","categories": [],
        "tags": ["Radiology","x-ray","kVp","mA","mAs"],
        "url": "/20220808/",
        "teaser": "/assets/images/20220808/0_.png"
      },{
        "title": "방사선 전문 용어 및 약어 정리(Radiation Terms and Abbreviations)",
        "excerpt":"  방사선 전문 용어                  명칭       영문명       설명                       X-선       X-Ray       가시광선 보다 짧은 파장을 가진 침투 이온화 전자기 방사선.                 감지기어레이       Detector Array       감지기 그룹과 감지기를 분리하는 사이 공간 물질. 컴퓨터 단층 촬영 내의 이미지 수신기.                 검출양자효율       Detective Quantum Efficiency, DQE       X-선 이미지 시스템이 이상적 감지기에 관한 높은 신호 대 잡음비를 가진 이미지를 효과적으로 생성하는 방법을 기술한다.                 경질 X-선       Hard X-Ray       X-선은 높은 침투성을 가지기 때문에 높은 품질의 이미지를 촬영할 수 있다.                 공간분해능       Spatial Resolution       높은 콘트라스트를 가진 작은 대상을 이미지화 하는 능력.                 공기케르마       Air Kerma       줄(J) 단위의 방사 에너지 양은 실제로는 공기의 단위 질량(kg) 내에 쌓이거나 흡수된다. 케르마 양은 J/kg 단위로 표현되며 이는 방사선 단위인 gray(G)이기도 하다.                 광자       Photon       질량도 전하도 없지만 마치 입자인 것처럼 사물과 상호작용하는 전자기 방사선. X-선과 감마선.                 광전증배관       Photomultiplier Tube, PMT       가시광선을 전기신호로 전환하는 전자 튜브.                 광전효과       Photoelectric Effect       광자에 끌려서 나타나는(금속과 같은 소재의) 전자 방출.                 광증폭기       Image Intensifier       낮은 방사선 노출을 가진 형광투시법 이미지를 생성하기 위해 사용된 전자 장치. 환자를 통과한 X-선 빔은 진공관 내에서 전자 패턴으로 변환된다.                 국제방사선방어위원회       The International Commission On Radiological Protection, ICRP       방사선의 방호에 관한 기본원칙을 확립하고, 국제적으로 적용해야 할 방사선 방호 체계 및 기준을 권고하는 독립 공익단체, 즉 비영리기구이다.                 낙하부하발생기       Falling Load Generator       노출 인자가 고전압 발생기에 의한 가장 짧은 노출 시간의 가장 높은 mA로 자동 조절된다.                 노출       Exposure       X-선 또는 감마선에 의해 공기 내에 생성된 이온화 측정. 뢴트겐, 킬로그램 당 클롱, 또는 공기 케르마로 표현된 방사선 강도.                 다중슬라이스전산화단층촬영       Multi Slice Computed Tomography       동시에 두 개의 나선형 슬라이스를 생성하기 위해 두 개의 감지기 어레이를 사용한 이미지화 양식.                 단층촬영       Tomography       단영상은 X-선 소스를 이동시켜 몸체를 통과하여 생성된다. 노출 동안 반대쪽에는 필름을 댄다. 초점면 내의 구조는 더 선명하게 나타나는 현편, 다른 평면 내의 구조는 흐릿해진다.                 대비       Contrast       방사선 사진의 밝은 부분과 어두운 부분 사이의 차이 정도.                 대상까지의영상수신기거리       Object To Image Receptor, OID       영상 수신기로부터 이미지화되는 대상까지의 거리.                 컴퓨터방사선촬영       Computed Radiography, CR       이미지 수용기로서 사진 증진 형광 물질(저장 인광)을 사용하는 방사선 기술. 결과 이미지는 컴퓨터 상에 디지털화되어 저장 및 공유할 수 있다.                 디지털방사선촬영       Digital Radiography, DR       평판 감지기를 포함한 디지털 X-선 센서가 정적 방사선 사진을 위해 전형적인 사진 필름을 사용하는 대신에 디지털 X-선 이미지를 사용한 디지털 X-선 이미지.                 디지털영상및의료통신       Digital Imaging And Communication In Medicine, DICOM       이 기종 영상 시스템과 통신하는 표준.                 디지털형광투시       Digital Fluoroscopy, DF       구역 X-선 빔과 이미지 증폭기 또는 평판 감지기를 사용하여 일련의 동적 이미지를 생성하는 디지털 X-선 이미지 시스템.                 밀리암페어       Milliampere, mA       X-선 튜브 전류 측정.                 밀리암페어초       Milliampere Second, mAs       노출 시간과 X-선 튜브 전류의 곱.                 반가층       Half Value Layer, HVL       최초 강도의 절반으로 X-선 빔을 줄이기 위해 필요한 X-선 흡수재의 두께.                 방사선량구조화된보고서       Radiation Dose  Structured Reports, RDSR       방사선 조차에 대한 구조화된 리포트. 검사 이미지 마지막에 헤더만 있는 작은 파일이 이에 해당.                 방사선촬영       Radiography       X-선 필름 그리고/또는 감지기를 사용하는 화상화 형태. 일반적으로 고정(정적) 이미지를 제공하기 위해 X-선 튜브를 사용한다.                 방사선촬영기법       Radiographic Technique       방사선 사진의 특정 품질의 이미지를 생성하기 위해 X-선 이미지 시스템 제어 패널에서 선택된 설정의 조합.                 방사선흡수선량       Radiation Absorbed Dose, RAD       흡수선량과 공기 커머를 위한 특별한 단위. 1 rad = 100 erg/g = 0.01 Gy.                 부채꼴빔       Fan Beam       하나의 슬릿으로서 투영된 컴퓨터 단층 촬영에서 사용된 X-선 빔 패턴.                 분광기       Collimator       X-선 빔 크기와 모양을 제한하기 위해 사용된 장치.                 빔제한장치       Beam Limiting Device       버키는 X-선 촬영을 하는 동안 그리드를 이동시키는 장치이다. 이 동작은 X-선 사진 상에 나타난 위치에 리드 스트립이 나타나지 않게 하는 동시에, 소음을 줄이고 진단을 위해 더 선명해진 이미지를 생성한다.                 산란방사선       Scatter Radiation       입사 X-선 빔의 방향으로 다시 산란되어 되돌아오는 X-선.                 산란방지그리드       Antiscatter Grid       잔여 X-선 빔 내의 산란 방사선 세기를 줄이기 위해 사용된 장치.                 선량계       Dosimeter       저너리 방사선 노출 감지 및 측정 기구.                 선량관리       Dose Area Product, DAP       선량과 노출 부위의 곱은 종종 Gy.cm2로 표현된다. 현대 X-선 시스템은 DAP 미터에 갖추고 있으며, 검사 동안 누적된 DAP를 기록 할 수 있다.                 선질       Radiation Quality       X-선 빔의 상대적 침투성은 평균 에너지에 의해 결정된다. 평균 에너지는 일반적으로 반가층 또는 킬로-볼트 피크에 의해 측정된다.                 실제초점크기       Actual Focal Spot Size       튜브 전류로부터 전자에 노출된 양극 대상의 부위.                 양자       Quantum       X-선 광양자.                 에너지삭감       Energy Subtraction       광전 상호작용 내의 차이가 초래하는 감산 영상을 제공하기 위해 두 개의 X-선 빔 에너지를 사용하는 기법.                 여과       Filtration       알루미늄 또는 다른 금속을 사용하여 유용한 빔으로부터 저에너지 X-선을 제거하며, 이는 빔 품질을 증대하고 환자 선량을 줄인다.                 역제곱법칙       Inverse Square Law       이 법칙은 특정 위치에서의 방사선 세기는 방사선 소스로부터의 거리의 제곱근에 역으로 비례함을 말하고 있다.                 연질X-선       Soft X-Ray       낮은 침투성을 가진 X-선. 따라서 이미지 품질이 낮아진다.                 영상수신기거리소스       Source To Image Receptor, SID       X-선 튜브에서 이미지 수신기까지의 거리.                 오프초점방사선       Off Focus Radiation       X-선 튜브 내에 생성된 X-선. 하지만 초점에 있지 않다.                 유방조영술       Mammography       낮은 킬로-볼트를 사용한 가슴 방사선 투과 시험.                 유효초점크기       Effective Focal Spot Size       환자 및 이미지 수용기에 투사된 구역.                 의료영상저장전송시스템       Picture Archiving Communication System, PACS       필름 없는 병원 시스템.                 이동그리드       Moving Grid       X-선 노출 동안 이동하는 그리드. 일반적으로 하나의 부키 내에서 발견된다.                 이온화챔버       Inoization Chamber       이온화 챔버는 모든 가스 충전 방사선 감지기의 가장 단순한 형태이며 전리 방사선의 감지 및 측정을 위해 사용된다.                 자동노출제어       Automatic Exposure Control, AEC       대부분의 X-선 이미지 시스템 내의 방사선 촬영 동안의 방사선 노출을 결정하는 기능.                 자동밝기제어       Automatic Brightness Control, ABC       방사선 전문의가 이미지 밝기를 선택할 수 있게 하는 형광 투시법 시스템 상의 기능. kVp, mAs, 또는 둘 모두를 변경함으로 자동적으로 유지된다.                 자료수집체계       Data Acquisition System, DAS       다중 슬라이스 스파이럴 컴퓨터 기반 단층 촬영 스캔 시스템의 각 방사선 감지기로부터 신호가 연결되는 컴퓨터 제어 전자 증폭기 및 스위칭 장치.                 전자볼트       Electron Volts, EV       볼트의 전기 전위 차이를 통해 이동된 단일 전자 방전에 의해 얻어진 에너지 양.                 전자의무기록       Electronic Medical Record       디지털 형태로 체계적으로 수집되어 전자적으로 저장된 환자 및 인구의 건강정보이다.                 전체여과       Total Filtration       X-선 튜브의 고유 여과와 추가된 여과와.                 조리개       Aperture       조리개 횡격막 내에서와 같이 진단 X-선 튜브의 고정식 콜리메이션(Collimation).                 조영       Contrast Medium       해부 구조 사이의 차이를 보강하는 물질.                 처방전달시스템       Order Communication System, OCS       병원에서 환자를 중심으로 일어나는 모든 과정을 전산화하는 것으로 병원정보시스템의 핵심이다. OCS는 의사, 간호사, 진료지원부서간의 정확하고 신속한 의사전달이 기본 기능이다.                 천연여과       Inherent Filtration       X-선 튜브 하우징 조립품의 영구적으로 설치된 구성요소 및 X-선 튜브 삽입 유리 윈도우에 의해 제공된 유용한 X-선 빔의 여과.                 촛점       Focal Spot       전자가 X-선을 생성하기 위해 상호작용하는 양극 대상 구역.                 컴퓨터단층촬영       Computed Tomography, CT       X-선 팬 빔 및 감지기 어레어를 환자 주위로 회전시킴으로써 인체의 횡단층 촬영 섹션을 생성하고 이미지 처리를 위해 컴퓨터를 사용하여 재구성한다.                 컴퓨터조영엑스레이촬영법       Digital Subtraction Angiography, DSA       동맥에 조영제를 넣어 촬영.                 킬로-볼트피크       Kilovolt Pead, kVp       X-선 튜브에 걸친 최대 전기 전위 측정. 킬로-볼트로 표현된다.                 튜브시동장치       Tube Starter       양극 X-선 튜브를 회전은 양극 조립체를 회전시키는 유도 전동기를 활용한다. 시동 장치 또는 모터 제어기를 회전을 위해 X-선 튜브 모터로 전원을 인가하기 위해 사용된다.                 해부학프로그램방사선촬영       Anatomic Programming, APR       콘솔에 (인간/동물) 일반 해부학 뼈대 이미지를 제시하는 그래프가 조사되는 특정 몸체 부분 (인간/동물) 만을 선택함으로써 원하는 kVp 및 mAs의 선택에서 기술분야 전문가를 가이드 하는 기법.                 혈관촬영법       Angiography       X-선 검사를 통한 혈관 시각화를 가이드 하는 형광 투시경 프로세스.                 형광투시법       Fluoroscopy       X-선 튜브가 여기되어 있는 동안 내부 구조 모션의 연속적 이미지를 제공하는 이미지화 양식. 실시간 이미지.                 후방산란방사선       Backscatter Radiation       대상과 상호작용하고 후방으로 방향 전환한 X-선.                 흡수선량       Absorbed Dose       조사 후 물질의 단위 질량당 전리 방사선으로부터 전달/누적된 에너지. rad 또는 gray로 표현됨.           약어                  약어       영문명       설명                       A       Allergy       알레르기내과                 ANE       Anesthesiology       마취통증의학과                 AP       Anatomical Pathology       해부병리과                 C       Cardiology       순환기내과                 CCU       Coronary Care Unit       관상동맥집중치료실                 CM / PM       Chest Medicine / Chest Pulmonology       호흡기내과                 CP       Clinical Pathology       임상병리과                 CS       Chest Surgery       흉부외과                 CV       Cardiovascular Medicine       심장내과                 DM       Dermatology       피부과                 DR       Delivery Room       분만실                 DT       Dentology       치과                 ED       Endocrinology       내분비내과                 EM       Emergency Medicine       응급의학과                 ER       Emergency Room       응급실                 ENT &amp; ORL       Ear, Nose, Throat &amp; oto rhino laryngology       이비인후과                 FM       Family medicine       가정의학과                 GI       Gastrointestinal Medicine       소화기내과                 GS       General Surgery       일반외과                 HM       Health Medicine       일반검진                 HO       Hematologiy - oncology       혈액종양내과                 ICU       Intensive Care Unit       중환자실                 IF       Infectious Disease       감영내과                 IM       Internal Medicine       내과                 MICU       Medical ICU       내과중환자실                 MS       Medical Service       종합검진                 NEP       Nephrology       신장내과                 NICU       Neonatal ICU       신생아중환자실                 NR       Neurology       신경과                 NS       Neuro Surgery       신경외과                 OBGY       Obstetrics &amp; Gynecology       산부인과                 OM       Occupational and Environmental       산업의학과                 OPH       Ophthalmology       안과                 OR       Operation Room       수술실                 OS       Orthopedic Surgery       정형외과                 PACU       Post Anesthsia Care Unit       회복실                 PD       Pediatrics       소아과                 PS       Plastic Surgery       성형외과                 PSY       Neuropsychiatry       신경정신과                 RD       Radiolgy       방사선과                 RH       Rheumatology       류머티스내과                 RM       Rehabillitation Medicine       재활의학과                 SICU       Surgical ICU       외과중환자실                 UR       Urology       비뇨기과          ","categories": [],
        "tags": ["Radiology"],
        "url": "/20220818/",
        "teaser": "/assets/images/20220818/0_.png"
      },{
        "title": "의료기기에 의한 방사선 노출과 위험(Radiation Exposure and Risk by Medical Devices)",
        "excerpt":"  CT나 X-ray 등 질병의 조기 발견이나 진단, 치료에 쓰이는 각종 기기는 고해상도 영상 출력을 위해 일정 수준의 방사선을 방출한다. 이로 인해 해당 기기로 진단이나 치료를 받은 환자는 방사선에 피폭(被曝, 인체가 방사선에 노출됨)된다. 하지만 이렇게 노출된 방사선이 인체에 위험한 것인지, 위험하면 어느 정도로 위험한지를 인지하기는 어렵다.   의료계용으로 쓰이는 방사선 방출 기기는 X선을 사용하는 CT나 X-ray 등이 있다. 암환자의 경우 고에너지 방사선을 이용해 암세포를 죽이는 방사선 치료를 하기도 한다. 방사선 치료는 암세포 사멸을 위해 반드시 필요한 경우이기 때문에 방사선 피폭에 대해 우려하는 경우는 적다. 하지만 CT나 X-ray와 같은 의료기기는 분석적 목적으로 방사선을 사용하는데 지나치게 사용하는 경우가 있어, 이에 따른 불필요한 방사선 노출에 대한 우려가 많다.   국내 CT 촬영 건수 및 CT 장비 보유 수      실제로 국내 CT 촬영 건수는 2010년 525만 건에서 2015년 770만 건으로 늘었다.(건강보험심사평가원 자료) CT 장비 수도 늘어, 2011년 2147대에서 2016년 2300대로 많아졌다. 국민 10만 명당 4.5대의 CT 장비가 있는 셈인데, 이는 OECD 국가 평균인 2.5대보다 많은 수준이다.(질병관리본부)   방사선 노출, 잠재적 위험   방사선이 인체에 미치는 영향은 크게 두 가지이다. 첫 번째는 방사선이 지나간 후 여기에 영향받은 세포가 죽어버리는 ‘세포 사멸’이고, 두 번째는 ‘암 및 유전적 영향’이다. 방사선의 세포 사멸은 방사선에 쏘인 즉시 나타나는 영향이기 때문에 ‘결정적’ 영향이라고 부른다. 하지만 암 및 유전적 영향은 오랜 시간 서서히 영향을 미치기 때문에 ‘확률적’ 영향이라고 한다.      보통 방사선 피폭을 나타내는 단위로는 ‘Sv(시버트)’나 ‘mSv(밀리시버트)’가 쓰인다.     1Sv = 1000mSv     1Sv는 단위 질량(kg)당 흡수된 총 방사선 에너지(J)를 기준으로, 1kg당 1J의 에너지가 인체에 미치는 정도를 나타낸다.    세포 사멸   방사선에 의한 세포 사멸 현상은 한 번에 높은 방사선량에 노출될 때 나타난다. 세포의 DNA 구조는 이중나선구조로 되어 있어 2개의 가닥이 있다. 방사선은 이런 세포 DNA 가닥을 끊어버린다. 세포 사멸 현상은 이렇게 끊어진 세포 DNA 가닥이, 세포의 증식 과정으로도 보충될 수 없을 때 나타난다.   피부 화상을 입는 증상부터 탈모, 소화기 점막 손상에 의한 염증 등 급성방사선증후가 나타난다. 심하면, 내부 장기가 딱딱하게 굳으면서 변형되기도 한다. 이런 세포 사멸 현상이 생기는 경우는 방사선 량이 최소 100-2000mSv를 초과할 때이다.      암 및 유전적 영향   DNA 가닥이 끊어진 모든 세포가 사멸하는 것은 아니다. DNA 가닥이 끊어져 한 번에 사멸시킬 정도의 방사선량이 아니라면, 세포들은 이 부위를 빠르게 연결해 회복을 시도한다. 그런데 이 과정에서 조금씩 변형된 DNA 세포들이 돌연변이를 일으킬 수 있다. 이런 돌연변이가 인체에 미치는 가장 중요한 영향이 암이다. 20-30년간 장기간에 걸쳐 돌연변이 세포가 증식하면, 결국 암을 유발할 수 있다.   암 및 유전적 영향의 경우에는 장기간에 걸쳐 영향을 미치기 때문에 영향을 미칠 수 있는 최소한도 방사선량이 어느 정도인지 정확히 알려져 있지 않다. 보통 전문가들은 100mSv 정도의 방사선량에 노출되면, 20-30년 후 암발생률이 0.5%가량 증가하는 것으로 본다. 여기서 100mSv는 한 번에 노출되는 방사선량을 의미한다. 방사선은 인체에 축적되는 것이 아니기 때문에, 50mSv에 두 번 노출된다고 해서 100mSv에 노출되는 것과 마찬가지로 암발생률이 0.5% 올라 간다고 볼 수 없다.      의료기기별 방사선 피폭량 수준   CT나 X-ray 등 의료기기를 통한 방사선 피폭은 어떤 기기인지와 더불어 어떤 부위를 촬영하는지에 따라서 달라질 수 있다. 신체에 따라 의료 방사선 노출 민감성이 다를 수 있고, 필요한 영상 정밀도가 달라지기 때문이다.   의료기기 방사선량과 비슷한 수준의 방사선량이 암발생률 증가에 미치는 영향은 다음과 같다.      대표적인 의료기기의 평균적인 방사선 피폭량 수준은 다음과 같다.                  종류       방사선량       암발생 위험       설명       진단질병                       가슴 X-ray       0.2-0.34mSv       최소 위험       흔하게 시행되는 방사선 검사 중 하나로 흉곽 부위를 X선으로 통과시켜 촬영해 폐와 심장 계통의 질환에 대해 검사.       폐렴, 폐결핵, 폐암, 폐쇄성폐질환 등                 흉부 CT       10-15mSv       낮은 위험 이상       흉부 CT는 X선 발생장치가 있는 원형의 큰 기계에 들어가 흉부를 촬영하는 검사법. 흉부를 가로로 자른 횡단면 촬영. 최근에는 기존 흉부 CT에서 방사선량을 10분의 1로 줄인 ‘저선량 흉부 CT’가 많이 쓰임.       폐암, 식도암, 결핵, 폐렴, 폐혈전색전증, 폐동정맥, 흉부기형 등                 뇌·두경부 CT       8-10mSv       낮은 위험       뇌·두경부 CT는 뇌와 가슴 위쪽 부위에 X선을 여러 방향에서 투과한 후, 각 방향에서 촬영된 사진을 수집해 컴퓨터가 재구성하는 촬영 기법.       뇌종양, 뇌경색, 뇌동맥류, 두개골절, 뇌출혈 등                 복부·골반 CT       10-15mSv       낮은 위험 이상       복부·골반 CT는 위가 위치한 횡경막에서 대퇴골(넓적다리뼈)까지 광범위한 부위를 촬영. 이에 따라 위나 간, 췌장 등이 위치한 상복부부터 대장이나 방광 등 하복부 소화기계질환 진단에 유용.       간암, 지방간, 담낭남, 담관암, 췌장염, 위암, 신장결석, 부신종양 등                 치과 CT·X-ray       0.011-0.09mSv       무시 가능한 위험       최과 진료시 사용되는 방사선 기기는 다른 진료 기기보다는 방사선량이 낮은 편. 대표적인 치과 방사선 사진으로 ‘디지털 파노라마’라고 해 치아 모양과 턱의 상태를 확인하는 기기의 경우 방사선량은 0.011mSv 정도이며, 치과용 CT(임플란트 시술 등 3차원적 진단이 필요한 경우)에는 0.03-0.09mSv 정도 방사선의 노출.       아이들 치아와 턱 성장 발육 상태 확인, 충치, 잇몸, 치아 뿌리 문제 확인                 PET-CT(양전자 컴퓨터단층촬영기)       20-30mSv       낮읜 위험 이상       PET-CT는 현재까지 알려진 암의 영상 진단 방법 중 가장 초기에, 가장 정확하게 암을 찾아낼 수 있는 최첨단 검사방법. 하지만 다른 진단기기에 비해 방사선량이 많이 방출된다는 단점이 있음. PET-CT의 촬영 기법은 양전자를 방출하는 방사선 의약품(포도당과 비슷한 물질)을 정맥주사한 후 전신 촬영을 해 몸 전체의 신진대사 흐름을 파악하는 형식. 이 물질이 특히 암조직 등에서 주위 정상조직보다 높은 농도로 측정되어 암을 정밀하게 판단함.       각종 암 및 치매           방사선 노출 안전 기준   국제방사선방호위원회(ICRP)가 정한 연간 방사선 노출량 권고 기준치는 일반인의 경우 1mSv 이하, 방사선사 등 방사선 관련 직업인은 50mSv 이하이다. 세계원자력협회에 따르면, 사람이 1년에 자연적으로 노출되는 방사선량은 평균 2mSv 정도다. 연간 방사선 노출량 권고 기준치는 이보다 낮은 1mSv이다. 하지만 이는 자연적으로 노출되는 2mSv 정도의 방사선량은 제외한 수치다. 여기에는 의료기기 진단 등으로 노출되는 방사선도 제외된다.   단지 국제 방사선방호위원회가 1mSv로 노출 권고 기준치를 정해놓은 이유는, 의료 목적도 아니고 방사선 관련 종사자도 아닌 사람이 1mSv 이상의 방사선에 노출되면 주변에 방사선을 발생시키는 원일 물질을 찾아야 한다는 의미에서다.   국제방사선방호위원회는 의료 방사선 노출 권고 기준치는 따로 정해두지 않았다. 실제로 암 치료시 방사능에 노출되는 양은 3000mSv가 넘기도 한다.(한국수력원자력) 진단이나 치료시 노출되는 방사선은 방사선에 노출되는 악영향보다 치료가 주는 효과가 더 즉각적으로 필요하고 크기 때문이다.   다만, 의료 행위 중 방사선 노출이 일어날 수 있는 ‘정당성’과 ‘최적화’가 확보되어야 한다. 즉, 환자의 방사선 노출이 불가피하거나 효과가 있을 때만 방사선 노출이 허용되어야 한다는 이야기다. CT촬영 시 지나치게 방사선량을 줄여 촬영해 해상도 낮은 촬영물을 얻는 것은, 방사선량을 높여 제대로 촬영하는 것보다 인체의 해로운 방사선 노출이라고 본다.         대처 방안      진단이나 치료 이익이 크다면 주저하지 마라. 방사선 노출이 두렵다고, 무조건 의료기구 사용을 자제하는 것은 오히려 다른 질병으로 인한 사망 위험을 높인다. 따라서 의료기기 사용으로 얻을 이득을 고려한 어느 정도의 방사선 노출은 감수하는 것이 옳다.   지나치게 두려워하지 마라. 방사선은 한 번에 큰 영향을 미치지 않으면, 세포 사멸 등 즉각적인 부작용을 받지 않는다. 또 기준치 이하의 낮은 방사선에 반복되 노출되더라도 인체에 쌓여 악영향을 미치지 않는다.   이유 없는 남발은 금물. 병원을 옮겨 다니며 동일 부위에 CT를 한 달 내에 재촬영하는 것은 피해야 한다. 한 달 내 재촬영이 인체 악영향을 준다기보다 재촬영 자체가 무의미한 방사선 노출을 가져오기 때문이다. 검사 시간을 최대한 줄이는 것도 방사선 노출량을 줄여 주기 때문에 중요하다. 검사가 한 번에 끝날 수 있도록 검사 요령을 환자가 미리 제대로 숙지하는 것도 필요하다.   임신부, 어린이 등은 더 주의하라. 나이가 어리거나 임신부의 경우는 방사선 노출에 더 위험할 수 있다. 따라서 가능하면 최대한 방사선 노출이 없는 검진으로 대체하는게 좋다. 나이가 어릴수록 방사선 노출에 의한 인체 영향도가 더 크기 때문이다. 1세 미만의 영아는 40-50대 성인보다 방사선에 3-5배 더 취약하다는 연구결과도 있다.  ","categories": [],
        "tags": ["Radiology","Risk","Medical Devices"],
        "url": "/20220930/",
        "teaser": "/assets/images/20220930/0_.png"
      },{
        "title": "C-arm",
        "excerpt":"  골절 수술하는 환자의 진료차트를 보면 많이 등장하는 C-arm 이란 수술장비가 있다. 특히 척추 관련 수술한 환자는 쉽게 접할 것이다. C-arm 명칭은 말 그대로 C자형 팔을 닮았다고 해서 붙여진 이름이다. CT와 같은 중대형 의료기기보다 훨씬 작고 이동이 가능하기 때문에 병원 규모에 설치 제약이 없다. 대학병원 응급실, 통증 치료센터, 개인 병원에서 사용되는 의료 영상 장치이다.   C-arm 이란   방사선 발생 장치를 이용해 생성된 X선을 연속적으로 방사하여 그 결과를 CCD(Charge Coupled Device, 전자결합소자) 카메라를 통해 시각화 시킨다. 디지털화 된 데이터 값을 모니터에 출력하거나 컴퓨터에 저장하는 시스템이다.      각종 수술실, 응급실 또는 기타 임상을 위한 처치 중에 사용되는 진단기기   뼈 및 관절, 혈관, 신경, 등을 실시간으로 투시하는 X-ray 장비   척추관 협착증, 척추수술 후 관절증, 각종 디스크 수술 중 병변의 유무와 크기 및 위치 등을 실시간으로 투시 촬영 할 수 있는 외과 수술용 이동형 X-ray 기기   구성      세부구성      Generator            A                    Type : High Frequency           Power Output (kW) : 3.5kW           Frequency : 40kHz           kVp Range : 40-110kVp           mAs Range : RAD - 0.4-200mAs  FLU - 0.2-4.0mA(Normal)  10.0mA(Boost Mode)                       B                    Type : High Frequency           Power Output (kW) : 12kW           Frequency : 40kHz           kVp Range : 40-110kVp           mAs Range : RAD - 0.4-200mAs  FLU - 0.2-4.0mA(Normal)  10.0mA(Boost Mode)                           X-ray Tube            A                    Tube Voltage: Radiographic 40-110 kV Max  Fluoroscopic 40-110kV Max           Focal Value : 0.5mm/1.5mm           Target Angle : 16°           Anode Heat Content : 50,000HU                       B                    Tube Voltage: Radiographic 40-125 kV Max  Fluoroscopic 40-125 kV Max           Focal Value : 0.3mm/0.6mm           Target Angle : 10°           Anode Heat Content : 300,000HU (210 kJ)                              제너레이터 및 튜브 구성은 출력 성능 별 구성 됨       Digital Camera            Image sensor : 7.4mm x 7.4mm       Active Pixel : 1,000 x 1,000       bit : 14bits           I.I            Image Intensifier size : 9”       Resolution (9″ at the center) : 52       Contrast ratio : 30:1           Collimator            Type : 3way Motorized       Vertical/ Horizontal/ Rotation           SCU            Dimension : 285(W)☓245(D)☓60(H)       Weight : 2.6kg       Power : 24V, 1.5A           Movement &amp; C-arm            Up-Down Distance : 450mm       Horizontal Distance : 200mm       Rotating Angle : ± 180˚       Orbital rotation : 135˚(90˚/45˚)       Panning motion : ± 12.5˚           Monitor &amp; Monitor Cart            Size : 17“ (19” is optional)       Resolution : 1280 x 1024       Power Requirement : 220V, 50/60Hz       Dimension : 1998 x 810 x 1806       Weight : 35kg           작동 원리      Generator : 필요 관전압 및 관전류 발생   X-ray Tube : X선 발생   I.I : 형광증배관에서 빛 신호로 전환   Digital Camera : 카메라를 통해 영상 획득   SCU : 컨트롤 유닛을 통한 각종 보정 조정   Monitor : 모니터를 통한 영상 확인   운용 방법      10 Ways Rotating Function       Digital C-arm의 주요 기능      Digital image processing(SVGA) : 디지털 이미지 처리 기능을 통한 최적의 영상 획득   Motion Detected Noise Reduction : 실시간 노이즈 제거 기능   Digital Zoom : 획득 이미지의 확대 축소 기능   Live Window Width/Level : 실시간 밝기, 음영 등 영상 조정 기능   ABS &amp; Over - Weight Fluoroscophy Mode : 자동 조사조건 조정 및 체형별 자동조건 조사 기능   Panning, Rotation : 사용 중 영상의 회전 및 획득 영상의 화면 이동 등 이미지 조징 기능   DICOM, Recording : DICOM 지원에 따른 PACS 연동 및 저장 이미지의 각종 파일형태 변경 기능   특징      실시간 진단과 시술이 동시에 가능하며 진료시간의 단축   외과적 수술 시 절개부위 최소화 및 수술시간의 단축   마취시간의 단축, 합병증 최소화   병변 부위를 정확히 찾아내어 진료가 가능함   모든 종류의 수술환자 및 응급환자 등에 용이하게 사용   주의 사항      방사선 노출에 따른 주의            장시간 사용 시 방사선 영향에 따른 문제점 내표       방사선 노출 주의 환자에 대한 관리 필요       방사선 피폭 보호를 위한 보호구 착용 필요           적용 분야      정형외과, 재활통증 : 골절관찰 및 접합수술, 경막외신경성형술, 인대강화주사요법, 통증차단술 및 각종 수술   신경외과 : 각종차단술, 대뇌혈관, 신경계 장애 진단 및 시술 등   내과 : 심혈관조형술, 담즙배액술 등   비뇨기과 : 신루성형술, 결석의 진단 및 시술 등   각종 병과 별 진단 및 시술에 적용   수의학적 적용      기침 원인 감별 진단/시술            기관 허탈/협착 정도 확인 진단 후 필요에 따라 스텐트 삽입       급/만성 기침 원인 진단           혈관 조영/각종 심장병에 대한 심혈관 중재 수술   식도, 위, 장내 이물 진단   식도/위/장 운동 이상 유무 진단   방광, 신장, 요관, 요도 결석/폐색 진단   간문맥 이상(PPS) 진단   각종 골절 진단/골절 정복수술 중 수술 상태 확인   연구개노장 상태 확인/진단 등  ","categories": [],
        "tags": ["Radiology","C-arm","Medical Devices"],
        "url": "/20221013/",
        "teaser": "/assets/images/20221013/0_.png"
      },{
        "title": "의료영상 저장 전송 시스템 (PACS, Picture Archiving and Communication System)",
        "excerpt":"  전세계적으로 컴퓨터를 이용한 시스템을 의학 분야에 적용하려는 시도가 붐을 이루고 있다. 특히 그 이용에 따른 부대 효과나 이용 효율면에서 직접적으로 도움을 받을 수 있는 처방 전달 시스템(OCS, Order Communication System)은 이미 국내의 여러 병원에 설치 운영되고 있다.   이러한 병원의 관리 업무 전산화를 넘어 진료 업무의 전산화에 대한 요구는 여기서 그치지 않고, 이미 선진국의 여러 병원에 설치 운영되고 있는 PACS, Teleradiology 등에 대한 국내의 관심은 어느 때 보다도 높고 그 실현 가능성도 높아지고 있다. 그러나 많은 의사 또는 병원 시스템 담당자, 의료기 관련 업무 종사자들의 이에 대한 이해가 부족하여 도입하고 싶은 시스템에 대해 지나친 환상을 갖거나 또는 지나친 회의주의로 인해 국내의 시스템 도입 사례나 운영 수준이 매우 낮음을 인정할 수 밖에 없다. 대형 병원에 도입된 PACS의 사례를 통해 그 시스템의 장점과 단점 등이 국내에 알려지면서 PACS 도입을 하고자 하는 국내 병원의 수가 점점 늘어가는 추세이다.   의학 영상 시스템에 사용되는 용어   RESOLUTION   해상도라고 해석 한다. 의학 영상이 컴퓨터의 화면에 표시될 때 어느 정도의 크기로 표시되는가를 설명하는 수치로 영상의 크기라고도 한다. 바둑판을 생각하면 가장 정확하고 이해하기 쉽다. 즉 디지털 영상은 화면에 표시될 때 가로와 세로로 구획을 나누어 이루어진 사각형을 기본단위로 화면상에 표시 한다. 이때 각각의 사각형을 PIXEL 이라고 부르고 하나 하나의 필셀은 동등한 밝기를 표시 한다. 해상도란 가로 픽셀 수 x 세로 픽셀 수로 표시하며 이는 영상이 얼마나 섬세한가를 나타내는 기준이 된다.   동일한 바둑판에 가로 19개 세로 19개로 이루어진 사각형의 크기와 가로 10개 세로 10개로 그려진 사각형의 크기를 생각하면 어느쪽이 더 자세한 화면을 표시할 수 있는가를 쉽게 이해 할 수 있다. 일반적으로 해상도는 높을 수록 좋은 영상을 표시 할 수 있으나 저장 용량과, X-ray, CT, MR, US 등 영상발생장치의 특성에 맞추어야 하므로 무조건 높은 것만이 좋은 것이 아니라 영상의 특성과 용도에 따라 적당히 선택해야 한다.   X-ray 필름   일반 가슴 사진 14”x17”의 경우 필름과 똑같은 해상도를 화면에 표시하기 위해서는 방사선 원자(또는 Film Grain)의 크기에 해당하는 사각형을 가져야 한다. 이는 현실적으로 불가능하며 인간의 눈으로 구별할 수 있는 능력의 한계와 기술적인 내용을 고려하여 결정된다. 일반적으로 가로 2048 세로 2560 정도면 방사선과 전문의가 판독하기에 문제가 없는 것으로 여러 논문에 보고되었고 또 현재 PACS를 사용하는 대부분의 병원에서 그렇게 사용 한다. 현재 X-ray의 경우 CR의 보급으로 PACS에 접목하여 사용하는 추세가 늘고 있으며 보통의 CR영상이 바로 위의 해상도를 제공 한다.   그러나 이 역시 엄청난 크기의 양으로 8-10MB에 이르는 크기이다. 그래서 주로 판독을 위주로 하는 방사선과용 또는 섬세한 영상을 요구하는 신경과 계통의 의사들에게는 위의 크기를 사용하고, 이미 판독된 영상을 이용하여 환자와 상담을 하는 일반 의사(방사선과 전문의가 아닌)용으로는 가로 1024 세로 1280의 영상을 사용하기도 한다. 이는 꼭 그래야 하는 것이 아니라 현재 고해상도의 영상을 표시하는 모니터나 저장 장치에 대한 효율성을 위해 이런 식으로 사용하는 것이다. 역시 필름보다는 못하지만 판독을 하고 진료를 행하는데 전혀 문제가 없다는 것이 일반적인 견해이다.   CT, MRI, US   원래 CT, MR Scanner 장비는 영상을 생성할 때부터 가로 512 세로 512의 해상도(또는 256 x 256, 128 x 128)로 영상을 구성 한다. 즉 영상 발생 방법이 디지털화 되어 있어 초기부터 일정 크기의 영상을 제공하므로 이를 화면에 표시하는 방법 역시 원래의 시스템과 같은 해상도를 사용 한다. 물론 1장의 Slice를 말한다. 반면 US 장비의 경우에는 아날로그 신호를 512 x 512 크기로 디지털화하여 사용 한다. 이때에는 별도의 장비가 필요하다.   Gray Level   일반적으로 분해능이라고 해석 한다. 이는 해상도와 함께 영상의 질을 좌우하는 척도로 사용 한다. 위에 예를 든 바둑판의 하나하나의 픽셀에 색을 입히는 경우 한 픽셀에 하나의 색을 사용하며, 사용할 수 있는 물감의 갯수가 하드웨어마다 정해져 있게 된다. 이 정해진 물감의 수를 분해능이라고 한다. 어린이들이 사용하는 12색 물감이니 24색 물감이니 하는 것과 같은 의미이다. 어느 경우 더 자세한 그림을 그릴 수 있는지는 자명 하다. 물론 가격도 엄청난 차이가 난다.   분해능을 이야기 할 때 256 Gray Level 또는 4096 Gray Level이니 하는 경우와 8bit 또는 12bit 라고 하는 경우가 있는데 이는 같은 말이다. 즉 8bit Image는 2의 8승인 256 Gray Level이 되며(256색 물감) 12Bit Image는 2의 12승 즉 4096 Gray Level이 된다.(4096색 물감) 분해능은 인간의 눈의 생리학적 능력상 흑백보다는 컬러에 더욱 민감하며 흑백의 경우 10-12Bit 이상에서는 그 차이를 느끼지 못한다고 알려져 있다. 즉 아무리 높은 분해능을 사용하여 영상을 보여주어도 우리는 느끼지 못한다는 이야기이므로 쓸데 없이 여기에 돈을 투자할 필요는 없다는 이야기이다.   X-ray Film   X-ray 필름의 Gray Level은 숫자로 표시 할 수가 없을 만큼 크다. 또한 필름의 종류마다 큰 차이를 보이고 촬영 방법, 현상 방법에 따라 큰 차이가 난다. 그래서 X-ray 필름의 경우 원하는 부위와 환자의 상태에 따라 촬영 기법이 차이가 나며 심지어 다시 촬영하는 경우도 생긴다. 일반 Chest 사진과 Breast 사진은 서로 비교할 수 없는 분해능을 가진다. 물론 이를 위해 촬영에 사용하는 필름과 기기가 차이가 나는 것이다. 이미 현상된 필름이 필름 스캐너로 디지털화 될 때 보통 12Bit 정도면 일반적으로 병원에서 진료에 사용하기에 충분한 것으로 알려져 있다.   CT, MR   이 경우에는 원래 영상이 디지털화 되어 생성되므로 상당히 높은 분해능을 가진다. 정교한 진료에 이용하는 이유가 바로 여기에 있다. 보통 12-16Bit를 사용하며 이는 장비에 따라 다르게 나타난다. 다만 장비에 붙어 있는 모니터에는 이 영역에서 일부분 즉 8Bit만을 사용하여 화면에 보여주며 필름화 할 때도 8Bit를 사용 한다. 잘 이해가 안될지 모르지만 영상의 원래 자료는 12Bit 혹은 16Bit로 디스크에 저장되어 있으나 이 저장된 영상을 화면에 보여 줄 때는 촬영 목적에 맞도록 보고자 하는 부위에 가장 적절한 8Bit를 사용한다는 것이다. 그 결과 같은 자료라도 보고자하는 부위에 따라 여러 가지 밝기의 영상을 얻을 수 있는데 이 8Bit 사용 영역을 Window라고 부르며 이렇게 보기 좋은 상태로 사용 영역을 조절하는 것을 Windowing 또는 Window Leveling 이라고 한다. 물론 PACS에서도 같은 기능의 분해능을 제공 한다. 이러한 Window Leveling 기능은 X-ray에서는 볼 수 없는 기능이며 PACS의 가장 유용한 기능이기도 하다.   US   초음파의 경우는 진료의 목적상 전체적인 패턴을 보기 위한 것이기 때문에 분해능을 상대적으로 낮게 설정 한다. 보통 초음파의 경우 영상 생성시에 8Bit로 생성 한다. 최근에는 많은 기술상의 발전과 컬러 혈류 영상을 보기 위해 16Bit로 영상화 하는 경우도 많아지고 있다. 다만 화면에는 이 역시 8Bit를 사용하여 보여주며 그 안에서 Window Leveling을 하게 된다. PACS에서도 같은 분해능을 제공 한다.   Image Size   영상의 크기는 해상도 x 분해능으로 표시 한다. 일반적으로 알려지기는 해상도로 알려져 있으나 PACS에서는 해상도 x 분해능으로 이해해야 한다. X-ray의 경우(CR로 촬영 한 경우) 2048 x 2048 x 16Bit = 8MB(Mega Byte)가 된다. CT, MR의 경우는 최대 512 x 512 x 16 = 4MB이다. 이러한 영상의 크기를 기준으로 전체적인 저장 용량과 네트워크 속도를 결정 한다. 즉 원래의 영상 그대로를 저장할 것이냐 혹은 위의 영상을 그대로 보는 것이 아니며 이미 판독된 영상이므로 크기를 줄여서 저장할 것인가 등을 병원과 업체간에 상담을 통해 결정 한다.   Compression Ratio   위에서 알 수 있듯이 의학 영상의 크기는 실로 엄청난 양에 이르기 때문에 저장 또는 전송의 효율을 위하여 압축(Compression)을 하기도 한다. 압축비(Compression Ratio)란 어느 정도로 압축을 하는가를 나타내는 수치가 된다. 물론 이 수치가 높다는 것은 적은 용량에 보다 많은 수의 영상을 저장할 수 있다는 장점이 있으나 방법상에 문제가 존재 한다.   영상의 압축은 그 방법상 2가지로 분리를 한다. 하나는 압축을 한 후 다시 복원을 하여도 그 복원된 영상이 수학적으로 원래 영상과 동일한 영상이 되도록 압축하는 방법이고(Lossless, Errorless, Noiseless, Reversible) 다른 하나는 이와는 반대로 복원된 영상이 원래 영상과 수학적으로 차이가 나게 되는 압축 방법(Lossy, Noisy) 이다. 전자의 경우 실질적으로 2:1 - 3:1 정도의 압축비를 가지고 후자의 경우 5:1, 7:1, 10:1 또는 그 이상의 압축비를 가질 수 있다. 각각이 장단점이 있으므로 사용자의 요구나 영상의 종류에 따라 다른 방법을 택하게 된다.   일부 논문을 통해 알려지기로는 10:1 Noisy 압축 방법을 사용하더라도 진료에 큰 어려움이 없는 것으로 보고 되고 있다. 또한 압축을 할 때 별도의 H/W를 사용하는 경우와 S/W만으로 압축을 하는 두 가지 경우가 있는데 각각 압축을 하고 복원을 하는데 소용되는 시간이 차이가 나게 된다. 물론 H/W를 사용하는 경우가 더 빠르나 좋은 방법으 S/W만을 사용하는 경우 큰 차이가 나지는 않는다. 영상의 압축은 비용보다는 시스템의 사용 목적과 영상의 종류에 따라 단계적으로 결정해야 한다. 또한 저장 장치의 종류도 고려되어야 한다. 일반적으로 오래되어 조회 빈도나 영상의 가치가 떨어진 경우에는 압축을 권장하나 그 외의 경우에는 압축을 권장하지 않는다. 압축의 방법으로는 JPEG, Wavelet, Hoffman등의 방법이 있다.   의학 영상 시스템의 목적에 따른 분류   일반적으로 PACS라 하면 큰 병원에 설치되어 모든 영상이 컴퓨터로 조회되고 병원에 필름이 없으며 모든 의사는 컴퓨터를 통해 영상을 보며 판독을 하는 시스템을 또는 온라인으로 멀리 떨어진 병원간에 환자의 영상을 주고 받으며 마치 전화를 하듯 진료를 하는 시스템을 상상 한다. 물론 틀린 이야기는 아니나 이는 PACS에 대한 오해를 불러 일으키기에 충분하다. 초기에 PACS 개념이 소개될 때 많은 의사들은 그런 시스템을 원했다. 반면 당시의 기술력은 그러한 시스템을 구축하는데 막대한 비용과 시간을 요구할 수 밖에 없었다. 그 결과 PACS에 대한 회의론이 지배적이었다. 이는 어떠한 시스템이든 시장에 처음 소개 될 때는 당연히 겪는 일이지만 PACS는 유독 심했던 것 같다. 컴퓨터 역시 초기에 개념이 소개될 때 과연 오늘날 같은 날이 올 줄 누가 알았겠는가? 어쨌든 최근의 PACS는 과거의 환상이 아닌 현실로 다가오고 있다. 누구나 원하는 목적만 정해지면 그에 맞는 시스템을 적당한 비용으로 구축할 수 있게 된 것이다. 아직도 위에 열거한 꿈이 이루어 지기에는 사회적인 인프라가 요구되나 적어도 병원의 요구에 맞는 시스템은 언제든지 저렴한 비용으로 구축할 수가 있다. 즉 적당한 비용만 지불한다면 위의 꿈이 현실로 될 수 있으며 그 비용이 크지 않다는 것이다. 또한 초기의 환상에서 벗어나 병원의 현실에 맞도록 시스템을 갖출 수 있게 되었다는 것이다. 가장 중요한 것은 우리 현실에 맞는 PACS는 어떠한 것이 가능한가 가 아닐까 싶다.   On - Call - Teleradiology   이 시스템은 주로 병원에 방사선과 의사가 고용되어 있으나 그 수가 많지 않은 반면에 병원의 방사선과 진료 빈도가 많은 경우나, 방사선과 진료 빈도가 낮은 분원으로써 본원에 방사선과 전문의를 두고 진료를 행하는 경우, 주변에 방사선과 전문 병원을 통해 영상 촬영과 판독을 의뢰하는 개인 병원, 의원 또는 CT, MR, US 등 각 분야의 전문가를 모두 보유하고 있지 않으나 그러한 영상 장비를 설치 운영하여 경우에 따라 상담용으로 사용하고자 하는 병원에서 주로 사용하는 시스템이다.   즉 평상시 근무시간에는 상주하는 방사선과 전문의를 통하여 현재 필름을 이용한 진료 형태를 이용하고 야간이나 응급 시 방사선과 전문의의 자택에서 전화선을 통한 모뎀을 이용하여 진료를 하거나, 의뢰된 환자의 영상을 필름으로 주지 않고 촬영과 판독 즉시 영상을 의뢰한 병원, 의원에 전송 하여 환자와 즉시 상담을 하는 경우 또는 주변의 전문의들간에 체인을 구성하여 영상 장비를 활용하는 경우 등 저렴한 비용으로 큰 효과를 볼 수 있는 실용적 시스템이다. 이 시스템의 특징은 다음과 같다.      일반 전화선을 이용한 상대적으로 낮은 속도의 전송매체(2.88kbps)   방사선과 전문의 자택과 병원을 연결   야간이나 응급 시 이용   사용 빈도가 비교적 낮은 경우   적은 비용으로 설치용이   분야별 전문가와의 상담용   영상을 보내는 쪽과 받는 쪽이 서로 다른 시스템으로 구성   주변 방사선과와 인근 병원의 체인식 운영   인터넷을 이용하여 비용이 거의 들지 않음   모 병원, 자 병원간의 컨설팅   산간 외지의 진료   이때 전송 시간은 다음과 같이 계산 된다.      해상도 x 분해능 / 전송속도 / 압축비 = 전송 시간(초)    이 시스템의 장점은 작은 비용으로 외부의 방사선과 의사와의 영상 전송을 통해 환자의 수술 여부, 이송 여부를 판단하는데 상당한 도움을 줄 수 있다는 것이다. 최근에는 인터넷을 활용하여 그 사용 영역이 무한대로 확장되어가고 있다. S/W만 갖추면 전세계 어느 곳과도 영상을 주고 받아 연구, 임상, 진료에 상당한 도움을 줄 수 있다.   Override Network   이 시스템은 위의 On - Call -Teleradiology와 동일한 기능을 수행하나 그 목적과 내용이 약간 다르다. 일반적으로 On - Call -Teleradiology과 Override Network를 통틀어 Teleradiology라고 한다. Override Network는 방사선과 전문의가 자신의 사무실을 갖고 주변의 중.소규모 병원과 연계 1:1 또는 1:N 연결을 하여 언제든지 빠른 전송 매체를 이용하여 병원과 영상을 주고 받기 위한 경우나, 병원과 분원 사이에 1:1 연결을 하여 비교적 잦은 빈도의 방사선과 전문의의 상담을 하는 경우에 사용 한다. 또한 각 부분의 전문가로 구성된 방사선과 전문의 여러분이 동시에 해당 지역의 병원과 연계, 영상을 주고 받는 경우에 사용 한다.   용도는 위와 동일하나 빈도가 잦고 속도가 빠르며 마치 네트워크 같이 동일한 병원으로 간주할 수 있기 때문에 위의 경우와 분리 한다. 이를 이용하면 병원이 방사선과 전문의를 고용하지 않더라도 소정의 판독료 만으로 방사선과 진료를 편하게 볼 수 있다. On Call 방식과 달리 상당히 빠른 전송 라인을 가지며 개념적으로 한 개의 병원과 같이 운영 된다. 이는 병원에 방사선과를 설치하지 않아도 또는 고가의 방사선과 영상 장비를 구입하지 않아도 주변의 장비와 인력을 활용할 수 있어 비용 효과를 노릴 수 있는 장점이 있다.      T1, ISDN 등의 비교적 고속의 통신망 이용(56kbps, 256kbps, 1.544Mbps)   마치 한 개의 병원과 같은 개념   잦은 빈도의 영상 전송   방사선과 전문의의 진료 영역 확장   각 부분별 전문의 사이의 연계   본원과 분원 사이의 상시 연결   고해상도의 영상 전송 가능   인터넷 이용 가능   인근 병원의 체인화   고가 장비의 공동 이용   실시간 영상 전송 가능(원격 진료)   이 시스템의 장점은 큰 병원이나 방사선과 전문 병원을 중심으로 주위의 개인 병원이나 분원 등이 상호 하나의 병원처럼 연결되어 방사선과 전문의를 한곳에 집중 상주시키거나 분야별 전문가를 분산 배치하고 장비를 공동 사용함으로 모든 분원과 주위 병원에 방사선과 의사가 필요 없게 되어 인건비를 절약 하면서도 보다 경험 있는 의사의 진단을 통해 효율적인 진료를 할 수 있다는 것이다. 또한 판독을 제공하는 중앙 병원이나 방사선과 전문 병원 입장에서는 고가의 장비의 사용 효율을 늘리고 주변 의뢰 병원에 바른 영상 전송을 해줄 수 있어 보다 빠른 진료를 하게 된다. 국가적으로는 고가의 장비의 중복 투자를 방지 수입대체를 꾀 할 수 있으며 환자에게는 어느 병원에 가더라도 영상의 종류에 따른 전문의의 진료를 받을 수 있게 되어 궂이 종합병원에 가지 않아도 전문적인 진료을 받을 수 있다.   MINI-PACS   PACS를 도입할 때 병원 전체에 한꺼번에 도입을 한다는 것은 경제적으로나 그 내용면에서나 상당한 모험이 되기 때문에 병원이 일부분 또는 현재의 시급한 당면 과제 해결을 위해 시스템을 도입한 후 점차 확대해 나가는 경향이 두드러지게 나타나고 있다. 이러한 접근법은 점차 PACS 도입의 기본이 되가고 있으며 경비면에서도 상당한 장점이 있다. 보통 CT, MRI 등의 장비를 도입 할 경우 그와 맞물려 PACS를 일부 도입하거나 또는 X-ray 장비의 어려움을 극복하는 CR을 도입하는 시점에서 PACS 도입을 고려하는 경우가 많다. 이를 Full PACS와 구분하여 Mini-PACS라 한다. Mini-PACS는 그 형태가 다양하여 이렇다 라고 정의 하기는 어려우나 다음과 같이 특징할 수 있다.      CT, MR, US 등 특정 장비 하나 또는 일부에 적용 하는 경우   방사선과 등 일부 과에만 적용하는 경우   응급실, ICU(집중 관리 병동) 또는 일부 병동에만 적용하는 경우   단지 보관용으로만 적용하는 경우   Teleradiology와 연계를 위해 설치하는 경우   CT - MR, CT - US 등의 장비와 장비간의 연결을 위해 적용하는 경우   교육용, 학술용으로 설치 운영하고자 하는 경우   필름 발생량을 줄이기 위해 도입하는 경우   환자와의 상담용으로 도입하는 경우   보다 정확한 진료를 위한 영상 후처리를 위해 도입하는 경우   병원의 인건비 절감을 위해   모 병원, 자 병원간의 네트워크   Teleradiology용으로 활용하기 위해   학술용 편집을 원활히 하기 위해   모두 병원 상황에 따라 설치 목적을 명확히 한 뒤 업체와의 충분한 상의를 통해 시스템을 도입해야 한다. 중요한 것은 이를 통해 병원의 모든 문제를 해결하려는 것이 아니라는 것이다. 보통의 경우 PACS하면 필름이 없어진다고 생각을 하는데 그렇지 않다. Mini-PACS의 경우 필요한 부분에만 필름을 공급하고 그 외의 진료에는 PACS를 적용하는 것이거나 필름을 사용하되 그 사용 방법과 빈도를 줄이는 것이 주요 목표이다. 결국 이 역시 업무 재정립의 절차를 요한다. 이미 선진국의 많은 사례들이 Full PACS의 성급한 시도에 대한 경고를 하고 있으며 반드시 초기의 설치 목적을 명확히 한 후 그 영향을 경험 있는 업체와의 충분한 상담을 통해 시스템을 도입해야 한다. Mini-PACS라는 말이 생긴 이유도 바로 여기 있다.   이러한 Mini-PACS의 도입에는 다음과 같이 고려할 사항이 있다.      현재 설치되어 있는 네트워크를 사용할 수 있는가?   보유하고 있는 장비에 별도로 필요한 사항은 없는가?   현재 운영되고 있는 각종 전산 시스템과의 연결은?   얼마나 많은 영상을 다루고자 하는가?   사용자가 누구이며 도입 이유를 충분히 알고 있는가?   사용자들에 대한 교육은?   사용 목적은 구체적으로 무엇인가?   이 때문에 진료 패턴에 영향은 없는가?   차후 얼마나 확장성이 있는가?   기존에 있는 장비를 얼마나 사용할 수 있는가?   시스템 도입 후 변화에 대한 대책은?   진료 시에 사용하는 것인가?   진료가 끝나고 일반 업무 시 사용하는 것인가?   설치 목적이나 이유를 실제 사용자가 잘 알고 있는가?   기존의 필름 대출 방식은 어떻게 바꿀 것인가?   현재 영상 장비의 종류, 스펙은 알고 있는가?   등 이 외에도 수 많은 질문에 답을 한 후 시스템 도입을 결정해야 한다. 실제로 설치 후 이와 같은 문제로 고가의 시스템이 무용지물이 되는 경우가 있다. 트랜드니까 따라가는 식의 결정은 병원, 업체 모두에게 피해를 줄 뿐이다. PACS는 일종의 집을 짓는 것과 비슷하다. 다 짓기 전에는 그 모양을 알 수 없으며 실제로 살아보지 않고서는 문제를 파악하기 쉽지 않다. 그러므로 예상되는 모든 문제를 사전에 충분히 검토 해보아야 한다. 대부분의 병원이 이러한 문제를 너무 어렵게 생각하거나 너무 쉽게 생각하여 PACS에 대한 그릇된 인상을 가지게 된다. 필요한 부분부터 단계적으로 접근하는 지혜가 필요하다.   시스템 구성요소      도입 목적의 정의   가장 중요한 사항으로 왜 우리 병원이 시스템을 도입하는가를 명확히 해야 하며, 이를 설치 업체에 명확히 전달하여야 한다. 예를 들면 “CT 장비에 있는 영상을 방사선과 의사가 쉽게 보고자 한다.” 라는 문구에는 저장이 목적이 아니라는 2차 목표 역시 명시 되어야 한다. 만일 저장이 목표라면 “하루 몇 명 정도의 환자가 있는데 몇일 정도의 자료는 몇분 이내에 보아야 한다.” 라는 구체적인 합의가 필요하다. 이와 같이 구체적인 합의가 되지 않고는 자금이 허락하는 한도에 시스템을 맞춰 도입하는 결과를 낳게 되고 이 경우 90% 이상 실패하게 된다. 개발 업체 역시 애매한 스펙의 정의보다는 여러 가지 종류의 스펙이나 요구 사항에 대한 정확한 문제와 해결책을 제시해야 한다.   PACS Architecture   PACS Architecture는 눈에 보이지 않은 부분이기 때문에 보통 PACS에서 간과되거나 잊게 되는 부분이다. Architecture란 저장 장치는 어디에 어떻게 둘 것이며, 각각의 부분들이 전체적으로 어떠한 구조하에서 연결이 되며 영상들은 어떻게 최초의 발생 시점에서 최종의 의사들에게 전달되고 그 후에는 어떻게 저장, 백업되는가 하는 일련의 설계도이다. 이러한 설계도가 잘못될 경우 향후 시스템을 확장하거나 이동할 경우 등의 변경이 어렵게 되는 경우가 있다. 전체적인 시스템을 보는 관점에서 설계되어야 지속적인 관리가 이루어 질 수 있다. 주로 저장과 관련된 설계가 대부분이나 다음의 네트워크와 관련되어 이루어진다.   네트워크 구성   네트워크 구성은 보편적으로 기존에 설치된 망을 이용하나 사용 목적에 따라 별도의 망을 설치해야 하는 경우도 있다. 즉 원하는 기능을 원하는 속도 내에 이루려면 초기 설치 시에 망에 대한 전체적인 고려를 해야 한다. 물론 차후 확장에 따른 것도 중요하게 고려 되어야 한다. 현재의 것만 고집하다 보면 역시 시스템 도입이 실패로 끝날 우려가 있으며, 이에 대해서는 과감한 결정이 필요하다. 대부분의 Mini-PACS에는 Ethernet을 사용 한다. 최근에는 ATM, Fast Ethernet 등의 보편화로 점차 사용 빈도가 높아지고 있다. PACS를 도입하려는 병원의 가장 큰 오류가 PACS는 꼭 FDDI와 같은 광통신을 사용해야 한다는 생각을 가지고 있는 것이나 이는 잘못된 생각이다. 위에서 언급 한대로 Ethernet이라도 용도와 설계를 잘하면 얼마든지 병원 실정에 맞는 시스템을 구축할 수 있다. 최근에는 인트라넷을 이용한 PACS를 구축하려는 시도도 활발히 이루어 지고 있다. 네트워크는 장비의 위치, 의사의 위치 외부 망과의 접속 방법 등이 정의되면 Architecture와 함께 Traffic을 예상하여 설계 된다.   영상 장비   병원에 있는 장비 중 어떠한 장비를 PACS에 연결 사용할 것인가는 시스템 설계와 도입에 가장 중요한 부분이다. 예를 들면 대부분의 병원에 X-ray 필름이 가장 양도 많고 사용을 많이 하는 필름이다. 이를 PACS에 연결 하기 위해서는 Flim Scanner를 사용해야 하며 그 시간이 장 당 약 30초가 걸린다. 이 경우 1000장을 입력하려면 30,000초로 약 8시간이 걸린다. 만일 PACS 도입 목적이 인건비 절감이라면 이 경우 1명이 하루 종일 스캔만 해야 하는 모순이 생긴다. 이 경우에는 오래된 필름만 보관한다라는 목적에는 맞으나 필름을 없애겠다는 용도에는 적당하지 않다. 만일 CR을 사용하여 필름을 없애겠다고 한다면 장당 8M에 해당하는 저장에 대한 해결책이 있어야 하며 판독을 위한 고해상도 모니터가 필요하다. 반면 MR만 연결하여 사용하는 경우 필름을 줄여 보겠다는 목적이라면 수 적은 저장 용량과 일반 모니터로도 가능하다. 즉 연결하고자 하는 장비의 특성에 맞도록 전체 시스템이 바뀔 수 있으므로 장비와 용도의 선정은 무엇보다 중요하다. 또한, 구형 장비의 경우 직접 연결에 의한 영상 획득이 쉽지 않으므로 CT, MR이라도 그 모델과 S/W Version 등에 따라 추가 비용이 들기도 하며 그 비용 또한 적은 액수가 아닌 경우가 많아 배보다 배꼽이 더 커지는 수가 생긴다. 또한 잘못해서 억지로 연결하는 경우 일이 늘어나거나 영상의 질이 떨어져 사용 효과를 반감하는 경우도 있다. CT, MR, US의 경우 Video Capture를 통해 얻은 영상은 원래 영상인 16Bit 자료가 아닌 화면상의 8Bit 자료이므로 이로 인한 영상의 손실이 생기며 X-ray의 경우도 Scanner를 통해 얻은 영상은 그 Bit Depth에 따라 손실이 생긴다. 일반적으로 초기에는 특정 목표를 분명히 한 후 도입을 상담하게 된다. 그러나 상담 도중 여러 가지 다른 목표가 생각나고 또 그것이 기술적으로 하자가 없으므로 이것 저거 쉽게 요구를 하게 되어 초기의 목표를 잊는 수가 있다. 처음부터 연결하고자 하는 장비를 정확히 선정하고 그에 따른 문제를 고려하여 결정해야 한다.   영상의 퀄리티   위에서 언급했지만 영상의 퀄리티는 용도, 영상의 종류, 예산의 범위 등에 따라 많은 영향을 받으며 이에 따라 가격도 엄청난 차이가 있다. 물론 기술적으로는 이미 상당한 수준의 영상의 퀄리티를 다룰 수 있다. 그러나 중요한 것은 가격보다는 그 종류와 용도라는 것이다.   이에 대해서는 경험 있는 업체의 조언을 받는 것이 좋은 방법이다. 이미 PACS가 설치된 병원으로부터 그 실례를 입증 받아 어떤 경우에 어떤 영상의 퀄리티면 충분하다는 것이 입증되어 있기 때문이다. 무조건 좋은 영상만을 고집할 것이 아니라 용도와 예산을 고려하여 결정해야 한다. 또한 압축은 어느 정도로 하며 과연 합당한가 등에 대한 사전 합의가 있어야 한다. 대부분 영상의 퀄리티를 위해 압축 하지 않으며 16Bit의 이미지로 생성 한다. 초음파는 Video Capture의 경우 Bit를 선택할 수 있으며 Image Filing을 지원 한다.   저장 장치   기술적으로 저장 용량은 무한히 늘릴 수 있다. 물론 예산이 가장 큰 문제이다. 실제로 Mini-PACS의 가장 중요한 제한 요인이 바로 이 저장 용량이다. 그러므로 다루어야 할 영상의 종류와 하루 발생량, 그리고 보관 기간과 보관 방법 등에 관해 미리 업체와 충분한 상담을 해야 한다. 여기에는 다음과 같은 사항을 고려해야 한다.      각각의 사용자에 부과되는 용량(개인 자료용)   중앙에 모두가 공유하는 용량(이미 진료가 완료된 환자 영상 저장)   지역적으로 분산 배치되는 용량(진료 중인 환자용)   읿정시간이 지난 후 백업되는 용량   즉시 볼 수 있어야 하는 용량   백업된 영상을 다시 보는 방법   하루 발생하는 영상의 용량   한번 발생한 영상의 각 단계별 사용 기간(촬영 -&gt; 진단 -&gt; 조회 -&gt; 보관)   최소로 보관하고자 하는 보관 기간   길게 보아 여기에 하나 더 단순 보관용 용량을 고려 할 수 있으나 이는 특별한 경우이다. 각각에 따라 저장 장치의 종류가 달라지고 그 속도 특성이 다르게 된다. 그러므로 용도에 따라 보관 기간이 결정되고 용량이 결정되어야 효율적인 저장 방법을 결정 할 수 있게 된다. 일반적으로병원의 경우 외래 환자가 내원하여 촬영하고 약 2주정도 촬영 영상을 본다고 한다. 그 후에는 거의 조회가 없으므로 최소 2주 정도는 On Line 조회가 되어야 한다. 그 후에는 Near Line에 저장되어 있다가 Off Line으로 옮겨 가는 일련의 계층을 가지고 설계 된다. 여기서 On Line은 보통 RAID 3 정도로 구성되며, Near Line은 Juke Box로 구성 된다. 또한 Off Line은 DAT, ODD 등으로 설계 된다. 일반적으로 약 1년 후에 10% 정도의 영상만이 재 조회된다고 한다.   저장 장치는 On Line 보관용과 Off Line 보관용으로 나누어 생각해야 한다. 즉 의학 영상은 그 용량이 크기 때문에 어떻게 저장하고 어떻게 조회되는가 하는 S/W 성능에 따라 저장 용량에 많은 차이가 생긴다. 가장 쉬운 것은 한군데 엄청난 용량의 저장 장치를 두고 사용하는 것이지만 이는 효율적이지 못하다.   PACS에 사용할 수 있는 저장 장치로는 Hard Disk, Optical Disk Juke Box, RAID, DAT 등이 있다. 저장 장치를 선택하는 방법은 먼저 용도와 용량이 결정된 후 각각의 특성에 맞는 것을 선택하면 된다. 여기에서 가장 중요한 것은 속도이다. Hard Dis는 속도가 빠르고 초기 설치비가 저렴한 반면 고용량으로 갈수록 가격이 기하급수적으로 올라가고 확장성이 없다. 주로 1TG의 임시 저장 장치로 가장 적당하다. Optical Juke Box는 초기 설치비가 많이 들고 속도가 상대적으로 느린 반면 고용량으로 확장을 할 수가 있으며 확장 시 비용이 저렴한 장점이 있다. 주로 Near Line 저장 장치로 사용하며 1TB 또는 그 이상에 사용 한다. RAID는 가장 최근의 1주 혹은 1달 정도의 자료를 보관하는데 적당하며 빠른 속도와 뛰어난 확장성이 장점이다. 주로 10-50GB 정도의 용량에 적당하다.   데이터베이스   PACS에서 가장 중요하면서도 그 중요성을 잘 느끼지 못하는 것 중에 하나가 데이터베이스이다. PACS에서 데이터베이스는 크게 두 가지로 구성 된다. 주로 영상을 관리하는 PACS 영상 DB와 영상과 관계된 각종 자료 즉 영상 장비와 관련된 촬영에 관한 자료, 판독에 필요한 각종 환자 자료, 의사의 판독 자료, 방사선과의 업무와 관련된 프로세스 자료인 RIS(Radiological Information System) 등을 관리하는 PACS-RIS DB이다. 대부분의 사람들이 PACS DB 하면 전자 즉 영상 DB만을 생각하여 일반적인 영상 DB로(예를 들면 회사의 서류 보관, 사진관의 사진 보관,방송국의 필름 보관 등과 같은 단순 영상 DB) 생각하여 PACS의 DB를 매우 단순하게 생각 한다. 그 결과 PACS를 마치 대용량의 영상을 저장하고 다루는 시스템 정도로 생각 한다. 실제로 PACS 업무를 하면서 많은 DB 업체, Optical Image Filing 업체 등이 PACS 개발에 뛰어 들었으나 이는 큰 오산이다. PACS는 의사들의 시스템이다. 또 그 의사들은 각각의 전문 분야로 전문화되어 그들 나름대로의 업무 방식이 있다. PACS는 병원의 의사를 위한 시스템으로 이러한 다양한 전문 분야의 전문가를 위한 시스템이고(병원만큼 수 많은 전문가 집단은 없을 것이다.) 모든 사람이 다양한 자료를 원한다. 또한 HIS(Hospital Information System), LIS(Laboratory Information System), RIS 등과의 연계가 되지 않고서는 사실상 Full PACS는 성립될 수 없다. Mini-PACS의 경우만하더라도 최소한의 RIS 자료가 필요하다.   즉 PACS Terminal에서 영상을 조회할 경우 현재 내가 보고자 하는 환자의 이름, ID, 위치, 입원인지 외래인지, 판독은 어떻게 진행되고 있는지, 어떠한 촬영 기록이 존재하는지, 과거 영상은 어떻게 판독되었는지, 이 환자와 비슷한 증상의 다른 환자는 없는지, 현재 얼마나 많은 영상이 존재하는지 등의 컴퓨터가 제공해야 하는 수 많은 정보가 필요하며 이중 하나만 가지고도 다른 모든 정보를 얻을 수 있어야 한다. 이와 같이 PACS의 DB는 PACS-RIS 즉 영상과 그 관련 자료 모두를 다룰 수 있는 능력을 가져야 한다. 왜 많은 Image Filing 업체들이 PACS를 못하는 지에 대한 이유는 여기에 있다. 근본적으로 최소한의 RIS 자료가 없이는(영상 촬영 예약, 판독 과정, 위치, 의뢰 의사, 판독의, 판독 결과, 과거 영상 기록 등) PACS는 단순한 Image Viewer 이상의 기능을 전달하기 어렵다. 단 하나의 PACS Terminal을 필요로 하더라도 이것이 PACS로 동작하기 위해서는 이러한 병원 업무 정보가 연동되어야 한다. 현재 한국의 대부분의 병원과 의사들이 Image Filing System과 PACS를 구별 못하는 이유는 바로 DB(PACS-RIS)의 기능을 이해하지 못하기 때문이다.   Performance   PACS는 시스템이기 때문에 그 결과는 전체적으로 평가되어야 한다. 즉 TV와 같이 하나의 제품으로 끝나는 것이 아니고 업무에 적용하여 운영해본 후 그 성능을 평가해야 한다. 이는 병원마다 시스템마다 다를 것이므로 도입 전에 원하는 Performance를 정의해야 한다. Mini-PACS의 경우 보통 모든 영상은 On Line 저장 장치에서 2초 이내에 조회되어야 한다. 이때 모든 영상의 정의는 다음과 같다.      2장의 X-ray(CR) 2k x 2k x 2Byte 영상   20장의 512 x 512 x 2Byte 영상   80장의 265 x 265 x 2Byte 영상   또한 Near Line에 있는 영상은 약 60초 이내에 조회 되어야 한다. 여기에 더 붙이자면 Teleradiology의 경우 3분 안에 최초의 영상이 떠야 한다든지 또는 이전의 Exam들이 수 초이내에 조회 되어야 한다든지 하는 용도에 따른 성능이 정의되어야 한다.   사용자 터미널   사용자 터미널은 시스템 도입으로 각각의 사용자 개인에게 주어지는 컴퓨터를 말한다. 가장 흔하게 볼 수 있는 터미널은 1)PC와 2)중.대형 컴퓨터에 키보드와 모니터만을 연결하여 사용하는 Dummy 터미널, 그리고 3)Work Station 이다. 세 가지 모두 장단점이 있으며 가격에 많은 차이를 보인다. 그러나 PACS 도입 시에는 해당 기능에 알맞은 사용자 터미널을 설치하게 된다. 물론 이 세 가지를 동시에 사용할 수 있으나 각각에 맞는 S/W가 별도로 개발 되어야 하며 각각의 기능에는 호환성이 문제가 될 수 있다. 그러므로 어느 사용자에게 어떤 터미널이 부여되고 어떤 일을 할 수 있는지, 어디까지 확장 할 수 있는지를 정의하여야 한다. 최근에는 Workstation이나 PC 성능이 별 차이가 없어 PC 사용의 사례가 늘고 있으나 반드시 PC가 유리한 것은 아니다. 아직 시스템의 안정성면에는 Workstation이 더 우수하기 때문이다. 또한 PACS의 경우 다양한 영상 장비와의 접속이 필요하나 대부분의 영상 장비들이 Workstation으로 구성되어 접속이 용이하다. 반면 PC의 경우 가격과 여타 S/W의 호환이 우수한 장점이 있다.   모니터   모니터는 크게 두 가지로 나눌 수 있다. 글자 위주의 작업에 적당한 PC용 모니터와 영상 위주의 작업에 적당한 영상 전용 모니터가 있다. 물론 가격에는 많은 차이가 있다. 영상 전용의 경우 다시 모양에 따라 Portraint, Landscape로 나누고 최대로 표시할 수 있는 영상의 해상도에 따라 나누어 진다. 또한 영상 전용의 경우 모니터 외에 해당 모니터와 컴퓨터를 연결하는 별도의 H/W가 필요하다. 물론 하나의 일반 모니터 또는 영상 전용 모니터에 문자와 영상을 모두 표시할 수 있으며 반대의 경우도 가능하다. 다만 사용자의 작업의 편리함과 영상의 종류에 따라 적당한 모니터를 선택하게 된다. 모니터에서 중요한 것은 표시되는 영상의 종류이다. 또한 그 밝기가 일반 모니터와 많은 차이가 난다. PACS에 대한 또 하나의 오류는 모니터에서 중요한 것은 해상도 라는 생각이다. 물론 영상의 종류에 걸맞은 해상도를 가져야 하지만 모니터에서 중요한 것은 밝기라는 것이다. 보통 의사들이 사용하는 View Box의 밝기가 약 300ft인 반면에 모니터로 낼 수 있는 최대 밝기는 기껏해야 200ft 정도이며 일반적으로 구입 가능한 영상 전용 모니터의 경우 80-150ft 정도이다. 또한 동시에 여러 개의 영상을 보아야 하므로 모니터의 갯수 역시 중요한 요소이다. 즉 사용자의 작업에 따라      일반 모니터   영상 전용 모니터   일반 모니터와 영상 전용 모니터   영상 전용 모니터 2개 또는 4개, 그 이상   시스템 구성에서 모니터가 차지하는 비중은 매우 크다. 마치 오디오에서 스피커의 성능과 같다고 할 수 있다. 그러므로 가격보다는 해당 작업이 원활히 이루어 질 수 있는 최소로 필요한 모니터를 결정하는 것이 무엇보다도 중요하다. 또한 모니터의 성능을 최대한도로 이용하는 S/W가 따라야 함은 당연하다. 영상 전용 모니터를 2개이상 사용하는 경우 각각의 모니터의 특성이 똑같아야 영상을 비교할 때 문제가 없다. 이는 판독에 매우 중요한 요인이 되기 때문에 반드시 의학 영상 전문 업체의 것을 사용해야 한다. 반면 CT, MR 영상의 경우에는 모니터의 역할 이 그리 중요하지는 않다. 충분한 영상 조절기능이 따라준다면 일반 PC VGA 모니터 상에 영상을 표시해도 판도에 전혀 지장을 주지않는다. 모니터는 사용자의 업무와 관련해서 선택해야 한다.   필름 스캐너   필름 스캐너는 Laser Scanner와 CCD Scanner 두 가지로 나눌 수 있다. 미국의 대부분의 PACS에는 Laser Scanner가 사용되고 있으나 고가인 것이 단점이다. 그러나 속도, 화질 모두 CCD에 비해 좋다. 반면 CCD의 경우는 상대적 저가로 인해 속도나 화질이 중요하지 않은 경우에 사용 한다. 물론 CCD의 화질이 판독에 지장을 줄 정도는 아니다. 최대 해상도는 양쪽 모두 비슷하며 필름 사이즈에 따른 해상도의 차이는 있을 수 있다. 또한 필름 자동 공급기의 부착 여부에 따라 가격 차이가 난다. 필름 스캐너를 선택할 경우에는 속도, 해상도, 분해능 용도 등을 고려하고 선택해야 한다. 14” x 17” 정도의 필름을 Scan 할 수 있어야 한다. 기존의 필름을 Scanner로 입력하여 PACS를 구축하겠다는 생각은 PACS의 기본 개념을 잘못 이해하고 있는 것이다. 최근 대부분의 PACS는 CR 중심으로 이루어지며 Scanner는 오래된 필름의 보관이나 PACS로의 이전 단계에서 잠시 사용하는 특수한 케이스로 사용 된다.   영상 획득 장치   PACS, Teleradiology 등에서 가장 기본이 되는 영상 장치와의 연결을 말한다. 즉 CT, MR, US 등의 영상 발생 장치로부터 영상을 컴퓨터로 가져오는 방법과 장치를 말하며 Video Capture와 Digital Interface 두 종류로 구분 한다. 이 사이에는 그 활용도와 영상의 질, 사용 방법에 현격한 차이를 보인다. 일반적으로 시스템 구축에서 기술적으로, 현실적으로 가장 난해한 부분이 된다. 이론적으로는 하나도 문제가 되지 않으나 영상 장치 업체가 다양하고 그들의 시스템이 다양하므로 쉬우면서도 까다로운 일이 된다. 최악의 경우 획득 장치에 들어가는 비용이 사용자 터미널 보다 고가가 되는 수도 있으며 획득 과정에서 많은 업무 부담과 장애에 부딪히는 경우도 생긴다.   Video Capture   마치 TV와 VTR을 연결 하듯 영상발생장치(CT, MR, US) 등과 컴퓨터 사이를 전선으로 연결하여 이를 통해 영상을 획득하는 방법이다. 이 경우에 컴퓨터 내부에는 별로의 영상 획득용 H/W가 필요하다. 영상의 질은 바로 이 H/W의 성능에 의해 좌우 되는데 보통 시중에 판매되는 일반용으로는 8Bit의 640 x 480 크기의 영상을 얻을 수 있다. 그러므로 CT, MR, US 등에 사용할 수 있으나 영상의 질이 우수한 편은 아니다. 또한 CT, MR의 경우 제조업체에 따라 각가 다른 신호를 사용하고 있으며 어떤 경우에는 이러한 장비에 사용할 수 있는 출력 형태를 제공하지 않는 경우가 있다. 그 결과 Video Capture 방법으로 원하는 시스템을 구성할 수 없는 경우도 있다. 주로 초음파 영상의 경우 이 방법을 사용 한다. CT, MR 등의 경우 이 방법을 적용할 때 영상의 질이 원래 영상과 많은 차이를 보이게 되어 대부분 사용하지 않는다. 또한 이 방법의 가장 중요한 문제는 Scanner를 사용할 때와 같이 판도에 필요한 환자에 대한 정보(이름, 성별, 나이, 검사 종류 등)를 일일이 별도로 입력해주어야 하는 불편함이 있다는 것이다.   Propriety Digital Interface   이 방법은 영상 발생 장치가 처음부터 Digital화 된 영상을 제공하는 CT, MR, CR에 사용할 수 있다. 즉 CT, MR 장비에 장칙된 저장 장치에서 특별한 연결 방식(SCSI, GPIB, Ethernet, FTP, DASM) 등을 통해 저장된 영상 파일을 바로 다른 컴퓨터로 연결하는 방법이다. 이 방법 역시 장비에 따라 별도의 H/W, S/W를 필요로 할 수 있다. 이 방법의 장점은 원래의 영상을 그대로 저장할 수 있다는 것과 함께 사용자 입장에서 위의 경우에 비해 상대적으로 편리하게 사용할 수 있다. 다만 이 경우에는 영상 장비 제조업체의 협조와 함께 해당 장비의 S/W의 수정이 필요하므로 장비 업체의 도움이 필요하다. 또한 경우에 따라서 영상을 검사 단위의 전송이 아닌 파일 단위의 전송을 해야 하며 파일의 변환 S/W가 필요하다.   DICOM(Digital Image Communication on Medicine) Interface   DICOM은 국제 방사선 학회가 정한 표준 프로토콜로 의학 영상의 전송과 관련된 표준 프로토콜이다. 이 방식에 따르면 모든 의학 영상은 일정한 형태의 파일로 구성되어 해당 파일에는 영상과 관련된 거의 모든 정보가 입력되어 있으며 이 방식에 의한 전송을 할 경우 업체에 관계없이 전세계 어느 장비 어느 컴퓨터라도 연결이 가능하도록 되어 있다. 대부분의 장비 업체가 이 방식을 지원하지 않았으나 워낙 이에 대한 요구가 강하고 또 PACS를 도입하기 위해서는 필수적으로 요구되는 사항이므로 최근 들어 대부분의 업체가 이를 지원 한다. 다만 이러한 모듈을 옵션화하여 장비 가격과 별도로 판매 하거나 자사의 장비만을 연결할 수 있도록 병원을 속이는 경우가 있다. 현재 GE, SIEMES, PHILPS, ISG 등 굴지의 업체들이 이를 지원하며 PACS 관련 장비를 개발하는 업체는 필수가 되고 있다. DICOM을 통해 영상 장비와 연결 할 때는 별도의 장비와 비용이 필요없으며 매우 간단하게 연결되고 또한 영상과 관련된 모든 정보가 전달 된다. 또한 향후 다른 장비를 구입 연결할 때에나 시스템을 확장할 때 전혀 문제가 없다. PACS 도입을 할 경우 반드시 DICOM에 의한 접속을 해야 하는 이유는 여기에 있다. 이러한 DICOM은 크게 두 가지로 분류된다. 하나는 DICOM File Format이고 다른 하나는 DICOM Communication Protocol이다. 즉 전자의 경우 BMP, PCX, TIF, JPEG 등과 같이 하나의 영상 파일이 어떻게 구성 되어야 한다는 규칙이다. DICOM 파일의 경우 그 Header에 거의 영상과 관계된 모든 정보가 들어갈 수 있도록 설계 되었다. 그러나 그 Header의 길이는 영상마다 다르다. DICOM Communication Protocol은 일종의 언어이다. 즉 기기와 기기간의 영상을 주고 받기 전에 서로 의사소통을 하기 위한 언어로 이는 또 여러가지 Service Class로 나뉜다. 예를 들자면 DICOM 파일 Format은 일종의 공통의 화폐이다. 또한 Communication은 언어이고 그 Class는 언어의 의미라고 해야 할 것이다. 똑같이 DICOM을 지원한다 하더라도 어떤 기기는 동일 언어 중에 5개의 단어(Class)만을 알아 듣지만, 다른 기기는 6개의 단어를 사용할 수 있을 수도 있다는 말이다. 이 경우 전자가 모르는 1개의 언어는 서로 사용할 수 없다는 말이 된다. 그 반대 역시 가능하다. 그래서 DICOM을 구현한 모든 업체는 자신들이 사용하는 단어를 반드시 일정한 규칙에 의해 공표 하도록 되어 있다. 그 결과 다른 업체, 장비에서 이를 이용하여 서로 의사소통을 할 수 있도록 만들 수 있는 것이다. 이를 DICOM Conformance Statements라 한다. 또한 DICOM에 의해 생성된 영상은 전세계에서 유일한 Code를 갖게 된다. 마치 인터넷의 IP Address와 같다. 그러기 위해 모든 Modality 생산 업체는 DICOM을 구현 하기 전에 ISO를 통해 자사의 유일한 user id를 획득해야 한다. DICOM은 머지 않아 의학 영상 분야의 표준으로 그 확고한 자리를 잡을 것이다. 아직도 ACR/NEMA에서는 DICOM에 대한 추가 사항을 꾸준히 개선, 향상, 확장하고 있다. 또 유럽, 일본 등에서는 이러한 표준안을 자국의 실정에 맞도록 수정하고 있어 앞으로의 무역 개방에 대비하고 있다.   영상 획득 장치를 도입 할 때에 고려해야할 사항은 다음과 같다.      영상 장비 제조업체   장비의 모델명   S/W version   Network Interface 지원 여부   Communication Protocol 지원 여부   DICOM 지원 여부   Laser Camera 연결 유무   시스템 도입에 관하여   PACS는 병원에 직접적으로 금전적인 해택을 주지 않는다. 물론 장기적으로 필름 발생량을 줄여가면서 얻는 금전적 해택과 간호사, 의사들의 노동력을 효율적으로 활용 하는데서 오는 이득을 시스템 도입 비용과 비교시 상대적으로 이득을 가져오는 것은 확실 하다. 다만 그것이 단기적으로 눈에 보이지 않을 뿐이다. 많은 병원 관계자나 PACS 업체가 이점에 대하여 산술적으로 얼마나 이득이 있는가를 여러 차례 계산했으나 인간의 노동에 대한 가격을 산정하는 것이 무의미 하며 또한 남는 시간에 대한 기회 비용 역시 산술적으로 따지기가 쉽지 않는 문제가 있다. 다만 현재 Digital 저장 장치의 경우 평균 1GB 당 50원으로 필름에 비해 큰 장점이 있게 된다. PACS 도입은 가격적인 면 뿐만 아니라 환자에 대한 서비스 개선, 병원의 효율성, 정보화 등의 추세에 맞는 변화의 한 과정으로 보아야 한다. 이러한 차원에서의 PACS 도입만이 병원과 의료계의 새로운 환경 적응이라고 할 수 있다.   병원의 특성에 맞는 의사결정   시스템을 도입하다 보면 예산상의 문제나 그 밖의 여러 문제로 원하는 수준의 시스템과 상당 부분 다른 그림을 그리게 된다. 이때 무엇보다도 중요한 것은 초기 목적에 얼마나 충실한가이다. 다른 병원은 이런 것도 한다던데 라는 식으로 비교하여 그 그림에 있으면 좋고 없어도 되는 사족을 달게 되면 결국은 애초의 목표를 벋어나는 경우가 생긴다. 예를 들면 X-ray Film 보관이 주 목적인데 나중에 판독을 하는 경우를 생각 하여 다른 병원의 판돈 시스템이 2k 시스템이라고 해서 2k 영상을 사용한다면 필요없이 고가의 Scanner, Monitor 와 함께 저장 용량도 손해를 보게 되는 것이다. 또한 이를 위해 기존 시스템의 연결까지를 고려한다면 오히려 PACS를 도입하지 않는 것이 좋다. 주 목적에 충실 하다 보면 상당 부분 양보를 해야 할 때가 있다. 이런 것은 나중에 해결 할 수 있는 확장성 만을 생각하여 초기 도입 시에는 병원의 현재 당면 과제 해결과 현재 시스템의 사용 담당자들의 의견과 특성을 고려하여 업체의 의견과 병원의 입장을 잘 고려하여 결정해야 한다.   도입 결정자와, 사용자의 생각   실제 사용자들이 시스템 도입을 통해 이득을 얻지 못하면 그 시스템은 무용지물이다. 단지 관리의 편리함, 대외 홍보만으로 시스템을 도입하게 되면 결국 피해를 보는 것은 사용자이며, 사용자가 만족하지 못하는 시스템은 실패로 끝나 돈만 낭비하게 된다. PACS는 병원 전체의 흐름에 영향을 주기 때문에 이에 대한 사용자들의 의견을 듣고 시스템 도입으로 사용자들에게 어떤 영향을 줄지 그 득과 실을 전달하여 공감을 얻어야 한다. 또한 이들의 생각이 시스템의 주요 기능을 결정하게 되기 때문에 사용자들이 이에 공감하지 않고서는 성공할 수 없다. PACS 도입에는 도입 결정자의 뚜렷한 도입 의지가 있어야 한다. 시스템의 도입으로 초기 상담 기간 동안 현재의 업무 외에 추가로 많은 업무가 중복하여 발생하며 초기에는 그 효과가 나타나지 않고 오히려 불편하기만 한 경우도 있다. 이 경우 보통 사용자 입장에서 강한 불만을 표시하거나 일부 경우 시스템 무용론을 주장하게 된다. 이를 참지 못하고 위에 언급한 도입 목표를 잊고 초기의 불편함만을 해소하기 위해 시스템 스펙을 변경하거나 계획을 취소하게 되는 사례가 있으므로 도입 결정자의 확고한 믿음과 추진 의지가 무엇보다도 중요하다.   PACS 도입으로 무엇이 달라지는가?   PACS라는 개념이 워낙 광범위한 개념이라 그로 인한 변화를 묶어서 이야기하는 것 자체가 일종의 오류일 수 있다. 몇 가지의 예를 들어가며 그 효과를 말하고자 한다.      ○○병원은 그 동안 CT, MR 장비를 운용하고 있엇으나 환자 수가 그리 많지 않고 병원 내에 MR 전문가가 있지 않아 평범하지 않은 MR 환자에 대해서는 판독을 하기 무척 어려웠다. 또한 그 외의 대부분의 환자는 일반적인 촬영이라 필름을 만들어 한번보고 마는 경우가 많았다. 반면 3-5년 장비를 운영 하다 보니 필름 보관이 무척 어려운 문제로 대두 되었다. 중소 병원이라 장소도 협소했고 관리도 허술하여 없어지는 필름이 무척 많아 걱정도 되었다. 그래서 CT, MR 장비를 하나의 네트워크로 묶어 한 개의 PACS W/S를 방사선과 과장 방에 설치 했다. 그리고 전용 라인을 이용하여 MR 전문의가 있는 주변의 대학병원과 연결하여 MR 영상에 대한 컨설팅을 받았다. 또한 필름 발생량을 줄이기 위해 모든 영상을 필름화 한 것이 아니라 일단 정장하여 방사선과 과장을 통해 판독을 받은 후 일부 젊은 의사들에게는 자신의 PC를 통해 상담을 할 수 있도록 하였다. 또한 정밀 판독을 위해 또는 환자 이송을 위해 꼭 필요한 경우만 필름 프린터를 통해 인쇄하여 보관 했다. 이를 통해 최소 50% 이상의 필름 발생을 줄였으며 분실은 거의 없어졌다. 또한 대학병원을 통해 애매한 환자의 영상에 대한 컨설팅을 받아 자신의 병원에서 치료할 수 있는데도 불구하고 다른 병원으로 보내는 환자가 무척 줄어 병원의 수익성에도 기여 했다. 또한 환자에 대한 이미지가 좋아져 환자가 늘었으며 간호사들의 일이 줄어 남는 시간에 환자에 대한 친절한 서비스가 가능해졌다. 또한 의사들이 필요한 영상을 언제든지 볼 수가 있어 진단, 연구에 많은 도움이 되었다. ○○병원 원장은 앞으로 모든 의사의 PC에 이를 확장할 계획이며 자신의 병원에 촬영을 의뢰하는 주변 개인 병원에도 이를 확장할 계획이다. 여기에 원장의 투자한 돈은 약 1억원 정도 였다.   ○○방사선과는 그 동네에서 유명한 방사선과로 CT, MR, US, X-ray 장비를 운영하고 있다. 많은 환자가 주변에서 의뢰가 들어와 하루에도 수백 장의 영상을 촬영 한다. 일이 너무 많아 일일이 이를 프린트하여 판독하고 환자에게 들려보내기가 매우 번거로웠다. 그래서 X-ray 장비를 CR로 교체하고 PACS를 이용하도록 전 장비를 연결 했다. 또한 주변의 병원에 인터넷을 이용하여 자신의 병원에 접속할 수 있는 인터넷 서버를 설치하였다. 원장은 자신의 책상에 전용 W/S를 설치하여 자리에 앉아서 모든 영상을 보고 자리에서 그 환자의 과거 영상까지 참조하여 정확한 판독을 입력 한다. 환자는 촬영만 하고 집으로 돌아가면 의뢰한 병원에서는 그 환자가 다시 내원 시 그 즉시 ○○방사선과에 접속하여 해당 환자의 영상과 판독을 본다. 필요하면 과거 영상까지 불러 자세한 설명과 병의 진척상황을 알려준다. 그 결과 ○○방사선과에는 필름을 필요로 하는 병원의 수가 반 이상 줄었으며 인근 병원 역시 빠른 서비스에 만족해 하여 의뢰 환자의 수는 늘었고 업무는 수월해졌다. 오히려 필름을 나눠주던 간호원 한명이 그만두었으나 채용할 필요가 없어졌다. ○○원장은 그동안 조금 불편했던 자신의 모니터가 2개인 W/S을 모니터 4개로 업그레이드 할 계획이다.   ○○대학병원은 이번에 다른 지역에 분원을 설치 했다. 그리 멀지 않은 곳이라 비용을 고려하여 방사선과 전문의를 따로 두지는 않았다. 그러나 분원에서 촬영한 영상이 이곳까지 와서 판독되어 다시 분윈으로 가는데 하루 이상의 시간이 걸려 분원의 일반 의사의 불만이 대단 했다. 그래서 할 수 없이 레지던트 한명을 상주 시켰으나 반 이상의 전문적인 판독은 역시 본원에서 해야만 했다. 할 수 없이 분원과 본원에 전용 라인을 설치하여 그 곳 장비와 이곳 장비를 연결하여 양쪽의 방사선과에 PACS W/S를 설치 했다. 그 결과 본원과 분원이라는 차이를 느끼지 못할 만큼 양쪽 모두 신속한 판독과 촬영이 가능해졌으며 레지던트의 교육 효과까지 생겨 본원에 의뢰하는 판독 역시 시간이 흐를 수록 줄었다. 장기적으로 본원은 MR 중심으로 분원은 CT 중심으로 운영을 해도 전혀 문제가 없을 것 같았다.   일부 꾸며낸 이야기 같지만 현실에서 얼마든지 가능한 이야기이다. PACS를 너무 어렵게 생각하여 필름 없이 어떻게 일을 하나 고민했거나 돈 많은 병원에서나 도입하는 시스템이라 생각했거나 아직은 먼 미래에 해당하는 시스템이라고 생각했다면 그 고민과 생각이 옳지 않다는걸 깨닫게 하는 예시임은 분명하다.   PACS 그 무한한 가능성      방사선과 전문의와 일반의, 병원의 각 과간의 의사 소통과 환자 진료 서비스를 개선한다.   쉽고도 빠르게 영상을 조회, 비교한다.   필름의 분실을 줄인다.   병원과 병원간의 서비스, 의사소통을 개선, 향상한다.   병원의 분야별 전문가를 충분히 활용한다.   환자에 대한 서비스, 개선, 시간 단축을 통해 상담의와 진료실에서 영상과 함께 대면 상담이 가능하다.   효율성 향상으로 병원의 수입을 증가시킨다.   필름 발생량을 줄여 필름 비용을 줄인다.   의사, 간호사 등 병원 직원의 단순노동을 줄여 환자 서비스 개선에 도움이 된다.   필름 보관과 관련된 공간, 시간, 인력을 줄인다.   영상 판독에 소요되는 불필요한 시간이 없어진다.   각종 영상 조정 기능으로 판독에 도움이 된다.   한번의 촬영으로 여러 명이 동시에 같은 영상을 보며 회의, 토론, 상담을 할 수 있다.   마지막으로 PACS에 대한 기존의 잘못된 편견을 지적하고 싶다. 이러한 편견을 극복하여 현재 많은 어려움을 겪고 있는 중소 병원의 업무 개선과 효율 향상에 도움이 될 것이라 확신한다.      PACS는 큰 병원에서나 하는 것이다. 아니다. 중소 병원 일수록 설치에 대한 효과를 짧은 시간에 적은 비용으로 효과를 볼 수 있다. 오히려 큰 병원일수록 복잡한 업무와 많은 이해관계로 PACS 도입에 어려움이 많아 긴 시간이 요구되며 성공하기도 매우 힘들다. 중소 병원에서 특화된 영역에 PACS를 도입하면 기대보다 상당한 업무 효율을 노릴 수 있다.       PACS를 설치하면 필름이 없어진다. 역시 잘못된 생각이다. 초기의 PACS는 필름을 없애기 위해 계획되었으나 그 것이 상당한 어려움과 적지않은 투자, 시간, 업무 재교육 등 많은 노력이 요구되는 것으로 인해 그 시도는 아직도 진행 중이다. 반면 필름 보조 시스템으로의 PACS는 이미 상당한 효과를 보고 그 효과가 입증되었다. 즉 필름을 없애기보다는 필름을 줄이고 보관을 용이하게 하며, 영상 사용 효율을 높이는 시도가 최근의 PACS의 주된 흐름이다.       PACS는 컴퓨터로 영상을 보는 것이다. 역시 50점짜리 답이다. 단지 영상을 컴퓨터로 보기 위함이라면 왜 많은 병원에서 이를 쉽게 설치 할 수 없을까? PACS는 일종의 업무 리 엔지니어링이다. 즉 정보화의 개념이 병원에 도입되어 보다 쉽고, 보다 빠르게 영상에 대한 모든 정보를 누구나 볼 수 있도록 하는 일종의 업무 전산화 시스템이다. 최근 거의 모든 기업에서 사용하는 업무용 MIS와 비슷한 개념인 것이다. 이 말은 병원의 업무(PACS 도입의 목적)에 맞도록 각종 주변 장비들과의 연동이 필요하다는 말이다. 왜 PACS S/W로 Paintbrush, Photoshop 등 각종 뛰어난 그래픽 도구들이 사용되지 않을까?       PACS 영상을 먼 곳에 보내고 받는 장치이다. 이 역시 50점. PACS는 System Integration이다. 즉 PACS안에는 수 많은 System이 함께 어우러져 동작하는 공장과 같다. 영상을 먼 곳과 주고 받는 것은 PACS의 한 System인 Teleradiology System을 말한다. 한국의 현실에서 가장 쉽고, 그 효과를 몸으로 느낄 수 있는 시스템이 바로 이 Teleradiology이다. Teleradiology는 단지 영상과 관련 자료만을 보내는 것이지만 반면 비슷한 개념으로 환자의 동화상을 함께 보내는(일종의 원격 회의와 비슷) Telemedicine 역시 최근 미 육국의 큰 프로젝트이다.       PACS로는 영상 판독이 불가능하다 절대로 틀린 말이다. X-ray의 경우는 최근 CR로 대부분 대체 되면서 디지털 영상으로도 얼마든지 판독이 가능함을 보여주었고 이를 모니터 상에서 판독을 하더라도 전혀 문제가 없음이 각종 학회 논문을 통해 알려지고 있다. 또한 CT, MR 등의 경우는 특별히 고가의 모니터를 사용하지 않더라도 일반 VGA에서 충분히 판독을 할 수가 있다. 최근에는 가장 미세한 영상인 Mammo 모차도 모니터를 통해 판독을 시도하고 있다.       PACS는 속도가 느려서 사용할 수 없다. 역시 잘못된 생각이다. 물론 전 병원에 걸쳐 모든 영상을 원하는 어느 곳에서나 빠른 속도로 볼 수 있도록 하려면 막대한 네트워크 비용이 든다. 그러나 최근의 추세인 Mini-PACS의 경우에는 현재 가장 일반적으로 사용하는 Ethernet을 이용하여 원하는 속도를 낼 수 있다. 또한 ATM, Fast Ethernet 등 FDDI와 같은 광통신보다 저렴한 가격에 바른 속도를 낼 수 있는 장비가 나오고 Architecture를 잘 설계하면 속도는 걱정할 필요가 없다.       PACS는 신설 병원에서만 설치할 수 있다. 이 역시 위의 Full PACS에 대한 생각에서 오는 틀린 생각이다. 오래된 병원이라도 필요한 부분만의 간단한 네트워크 설치로 Mini-PACS, Teleradiology 등을 얼마든지 활용할 수 있다. 물론 신설 병원의 경우 병원 건축 시에 미리 PACS를 고려 네트워크 설치를 하면 추후 시스템을 도입할 때 비교적 편리한 장점이 있다.       PACS는 방사선과용 장비이다. 물론 PACS는 방사선과와 밀접한 관련이 있다. 그러니 실질적으로 PACS 도입으로 혜택을 보는과는 방사선과 이외의 과이다. 즉 그동안 필름으로 부터 소외되거나 필름 보기가 상당히 불편했던 것이 없어지고 원할 때 언제든지 영상을 볼수 있기 때문이다. 방사선과는 PACS의 주 사용자로서 다른 과의 의사들이 보다 쉽게 방사선과의 서비스를 받도록 하는 역할이 주어진다. 물론 PACS 도입으로 방사선과의 업무 효율은 상당히 향상되며 임상 연구가 축적되는 장점이 있다.       PACS는 병원의 모든 정보를 장악하는 동맥이 될 것이다.   ","categories": [],
        "tags": ["Picture","Archiving","Communicaition","System","DICOM"],
        "url": "/20221014/",
        "teaser": "/assets/images/20221014/0_.png"
      },{
        "title": "Enuspace",
        "excerpt":" enuSpace는 HMI, SCADA, DCS, IOT, AI 분야에서 활용되는 다기능 통합개발자 솔루션이다. 그래픽 편집 및 런타임 뷰어 기능을 포함하고 있으며, 동적 데이터 가시화 도구를 제공한다. 객체 지향 프로그래밍(Object Oriented Programming:OOP)개념을 도입한 사용자 정의 라이브러리를 생성하여 그래픽 컴포넌트로 적용할 수 있다.   enuSpace는 동적 디스플레이와 시뮬레이션 도구가 통합되어 로직 및 알고리즘 라이브러리 블록을 이용하여 데이터 연결선(Link Object) 만으로 플로우베이스 프로그래밍(Flowbased Programming)을 지원한다. 연산 결과는 동적 디스플레이 객체를 통해 표현한다.   enuSpace는 소프트웨어 개발자 도구(Software Development Kit :SDK)를 제공하며, SDK 그래픽 기능을 활용하여 빠르고 수려한 윈도우 그래픽 프로그램을 개발하는데 강력한 엔진을 제공한다.   홈페이지   매뉴얼  ","categories": [],
        "tags": ["solution","editor","graphics","lua","javascript","enuspace"],
        "url": "/sites/enuspace/",
        "teaser": "/assets/images/sites/enuspace_.png"
      },{
        "title": "Minimal Mistakes",
        "excerpt":" Minimal Mistakes는 개인 사이트, 블로그 및 포트폴리오 구축에 적합한 Jekyll 테마 중 유연한 2열 테마이다. 이름에서 알 수 있듯이 스타일링은 최소한으로 제공하며, 사용자 정의에 맞는 다양한 기능을 지원한다.   테마 가이드  ","categories": [],
        "tags": ["jekyll","theme","minimal","mistakes"],
        "url": "/sites/minimal-mistakes/",
        "teaser": "/assets/images/sites/minimal-mistakes_.png"
      }]
